# 3. 자바스크립트 뿌리 파헤치기

# 3.1 이터레이션(Iteration pattern)

💡 목적  
: `데이터 전체를 한 번에 처리하는 대신`, 데이터를 `일정 단위로 쪼개어` 이 조각들을 `차례대로(순회하며)` `점진적으로 처리`하는 아이디어에서 출발  
- 대용량 데이터나 크기를 알 수 없는 데이터 컬렉션을 처리할 때, `표준화된 방법`을 제공하여 반복 작업을 `범용적`이고 `효율적`으로 수행하도록 도움  
- 질의 결과가 수백, 수천 줄 이상이 될 때처럼, 데이터를 루프 등을 사용해 반복적으로 처리해야 할 필요성이 있을 때 사용  


💡 구성 요소 및 동작 방식  
: 이터레이터 패턴의 핵심은 데이터에 접근하고 처리하는 방법을 표준화하는 것  

- `이터레이터(Iterator)`: 처리할 데이터를 참조하는 `데이터 구조`  
- `next() 메서드`
    - 이터레이터가 지원하는 핵심 메서드
    - 이 메서드를 호출할 때마다 데이터의 **다음 조각(레코드, 줄 등)**이 차례대로 반환  
- `반복 작업 종료 신호`:
    - 데이터 조각의 개수를 사전에 알기 어려운 경우, 이터레이터는 데이터를 `전부 처리했을 때` 다음 작업이 없음을 알리는 `특별한 값`을 사용하거나 `예외를 발생`시켜 반복 작업이 종료되었음을 알림  

💡 자바스크립트에서의 이터레이터 프로토콜 (ES6)  
ES6 명세서에는 자바스크립트 내장 문법을 통해 이터레이터 패턴을 구현하기 위한 `구체적인 프로토콜(규약)`이 추가  

- `next() 메서드의 반환 값`
    - `next()`는 반드시 `이터레이터 결과 객체(iterator result)`를 반환
- `이터레이터 결과 객체의 프로퍼티`
    - `value`: 반환된 데이터의 실제 조각
    - `done`: 반복 작업의 완료 여부를 나타내는 `불리언 값`
        - 반복 작업이 끝나지 않은 경우: `done`은 false
        - 반복 작업이 종료된 경우: `done`은 true

➡️ 이터레이션 패턴은 `다양한 형태의 데이터 컬렉션`을 `동일하고 예측 가능한 방식`으로 순회하고 처리할 수 있게 해줌으로써, 코드를 `깔끔하고 이해하기 쉽게` 만들어 줌


### 3.1.1 이터레이터 소비하기  
: 이터레이션 프로토콜을 통해 얻은 `데이터 조각(이터레이터 결과 객체)`을 실제로 어떻게 활용하고 처리(소비)하는지


💡 기본  
ES6에서 정의한 이터레이션 프로토콜의 가장 기본적인 방식은 이터레이터 객체의 **`next()` 메서드를 직접 호출**하여 데이터를 순차적으로 처리

  - 반복 중단:  `next()` 호출의 반환값인 **이터레이터 결과 객체**에서 \*\*`done` 프로퍼티가 `true`\*\*로 확인되면 반복 작업이 중단
    ➡️ 이 방식을 직접 구현하려면 매번 `next()`를 호출하고, 반환된 객체를 확인하며, `done` 값을 체크하는 **번거로운 과정**이 필요
    
```javascript
// 1. 첫 번째 호출
console.log(iterator.next());
// -> { value: 1, done: false }  (순회 계속)

// 2. 두 번째 호출
console.log(iterator.next());
// -> { value: 2, done: false }  (순회 계속)

// 3. 세 번째 호출
console.log(iterator.next());
// -> { value: 3, done: false }  (순회 계속)

// 4. 마지막 호출 (데이터가 모두 소진됨)
console.log(iterator.next());
// -> { value: undefined, done: true } (순회 종료)
```


💡 표준화된 이터레이터 소비 방법

내부적으로 이터레이터 프로토콜을 준수하며, 개발자는 더 깔끔하고 간결하게 이터레이터를 소비할 수 있음 개꿀임  

💭 `for...of` 반복문  

```javascript 
// 처리하려는 데이터의 이터레이터
var it = /* ... */;

// iterator result 객체를 순회
for(let val of it) {
  console.log('이터레이터 값: ', val);
}
```
:  `for...of`는 이터레이터(`it`)가 `done: true`를 반환할 때까지 자동으로 `it.next()`를 반복 호출하고, 반환된 객체의 `value` 프로퍼티를 `val` 변수에 할당  

💭 전개 구문 (Spread Syntax: `...`)  
: 전개 구문은 이터레이터에서 데이터를 **추출해 펼치는 주체**, 즉 **이터레이터 소비자** 역할

| 표현식 | 역할 (대칭 형태) | 소비 역할 |
| :--- | :--- | :--- |
| **`...`** (전개 구문) | **값을 펼침** (이터러블을 배열이나 함수 인수로 확장) | **이터레이터 소비자** |
| `...` (나머지 매개변수) | **값을 모음** (여러 인수를 배열로 묶음) | 해당 없음 |

1. 배열에서 전개 구문 사용 (이터레이터를 배열의 요소로 펼치기  

```javascript
// 이터레이터를 펼친 결과가 배열의 각 요소가 되도록
var vals = [...it];
```
: 이터레이터 `it`에서 `next()`를 반복적으로 호출하여 얻은 **모든 `value` 값**을 추출하고, 그 값들을 새로운 배열 `vals`의 개별 요소로 펼쳐 넣음   

2. 함수 호출 시 전개 구문 사용 (이터레이터를 함수 인수로 펼치기)  

```javascript
// 이터레이터를 펼친 결과를 함수 호출문에 넘겨 각 값을 인수로 사용
doSomethingUseful(...it);
```
: 이터레이터 `it`에서 얻은 **모든 `value` 값**을 추출하여, 함수 `doSomethingUseful`을 호출할 때 **개별적인 인수**로 전달  


➡️ `for...of`와 전개 구문(`...`) 모두 내부적으로 **이터레이터 소비 프로토콜**을 준수  
이 문법들을 통해 이터레이터가 제공하는 값들을 추출하여 배열, 인수 목록 등 **원하는 구조에 간결하게 할당**할 수 있게 되며, 이것이 이터레이션 패턴의 범용성과 유용성을 높여줌
