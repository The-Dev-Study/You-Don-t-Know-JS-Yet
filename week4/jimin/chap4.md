# 더 큰 그림

## 자바스크립트의 스코프 (Scope)
스코프란 변수와 상수가 코드의 어디에서 선언되었으며, 어디까지 접근 가능한지를 규정하는 규칙  
  
🔎 렉시컬 스코프 (Lexical Scope)  
- 자바스크립트는 렉시컬 스코프를 사용
  ➡️ 변수/함수의 스코프가 코드를 작성하는 순간(어휘적 위치)에 결정된다는 뜻
  함수가 어디서 호출되었는지가 아니라, 함수가 코드상 어디에서 정의되었는지를 기준으로 상위 스코프가 결정 (호출 시점 기준인 동적 스코프와 다름)
  
   * (1) 호이스팅 (Hoisting):
     * 코드를 실행하기 전에, 인터프리터가 해당 스코프 내의 모든 변수 선언($var, $let, $const) 및 함수 선언을 마치 스코프의 맨 위로 끌어올린 것처럼 처리하는 현상
     * 실제 코드가 움직이는 것은 아니지만, 선언을 미리 알게 되어 해당 스코프 시작 시점부터 변수/함수를 사용할 수 있음
   * (2) var의 스코프:
     * var로 선언된 변수는 함수 스코프를 가짐 즉, for나 if 같은 블록(`{}`) 안에서 선언되어도 해당 블록을 감싸는 함수 전체에서 유효
## 클로저 (Closure)
클로저는 자바스크립트의 렉시컬 스코프 모델이 만들어내는 자연스러운 현상  
함수와 그 함수가 선언될 당시의 렉시컬 환경(주변 스코프의 변수들)의 조합이 클로저
 * 작동 방식:
   * 어떤 함수가 바깥(외부) 스코프에 있는 변수를 참조하고 있을 때,
   * 이 함수가 외부 스코프에서 벗어나 다른 스코프에서 실행되더라도,
   * 이 함수는 원래 정의되었던 스코프의 변수를 계속해서 기억하고 접근할 수 있음
     (예시: 공장에서 만든 물건(함수)을 다른 곳(별개의 스코프)으로 가져가도, 물건이 만들어질 때 함께 있던 재료들(외부 변수)을 계속 쓸 수 있는 것과 같다)

## 프로토타입 (Prototype)
- 자바스크립트는 클래스 기반 상속이 아닌 프로토타입 기반 상속 모델을 사용
- 프로토타입 체인: 객체가 특정 속성이나 메서드를 찾을 때, 자신에게 없으면 프로토타입 링크를 따라 부모 객체로,
그 부모가 없으면 또 그 부모로 계속 거슬러 올라가며 찾습니다. 이 연결 고리를 프로토타입 체인이라고 부름

## 타입과 타입 강제 변환 (Types and Type Coercion)
- 자바스크립트는 런타임에 타입이 결정되는 동적 타입 언어  

  
타입 강제 변환 (Coercion): 자바스크립트가 연산자나 문맥에 따라 값의 타입을 자동으로 다른 타입으로 변환하는 것
   * 예: $5 + "10"$은 숫자를 문자열로 강제 변환하여 $"510"$이 됨
   * 개발자는 이 메커니즘을 정확히 이해해야 예상치 못한 버그를 방지할 수 있음

