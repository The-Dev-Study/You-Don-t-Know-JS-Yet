# 유돈노jsyet 스터디

### 1.2 컴파일 vs 인터프리트

전체 파일을 읽어 실행 가능한 파일로 변경하는 **컴파일**

한줄 한줄 읽어 실행하는 **인터프리트**

JS는 컴파일 언어에 가깝다

### 1.3 코드 컴파일

전통적인 컴파일러 이론에서는 1. 토크나이징/렉싱 2.파싱 3.코드 생성  의 과정을 거친다

다만 JS엔진은 이보다 훨씬 복잡하게 돌아간다

### 1.3.1 필수 두 단계

선 컴파일 후 실행을 거친다

이를 입증할 수 있는 JS의 세 가지 특징으로 구문 오류, 초기 오류, 호이스팅이 있다

- 1. 구문 오류 (SyntaxError)

```jsx
var greeting = "안녕하세요.";
console.log(greeting);

greeting = ."안녕!";
// SyntaxError: unexpected token.

```

JS가 한 줄씩 실행된다면 `console.log()`가 먼저 출력되어야 하지만, 실제로는 아무것도 출력되지 않고 바로 SyntaxError가 발생한다. 이는 프로그램 실행 전에 전체 코드를 먼저 파싱(컴파일)한다는 증거다.

- 2. 초기 오류 (Early Errors)

```jsx
console.log("잘 지내시죠?");

saySomething("안녕하세요.", "안녕!");
// Uncaught SyntaxError: Duplicate parameter name not allowed in this context

function saySomething(greeting, greeting) {
  "use strict";
  console.log(greeting);
}

```

strict mode는 함수 본문에 있지만, 중복 파라미터 에러는 함수 호출 전에 발생한다. JS 엔진이 코드를 사전에 분석(컴파일)해야만 이런 에러를 미리 감지할 수 있다.

- 3. 호이스팅 (Hoisting)

```jsx
function saySomething() {
  var greeting = "안녕하세요.";
  {
    greeting = "잘 지내시죠?"; // ReferenceError 발생
    let greeting = "안녕!";
    console.log(greeting);
  }
}

saySomething();
// ReferenceError: Cannot access 'greeting' before initialization

```

`let` 선언이 아래에 있는데도 위에서 에러가 발생한다. JS 엔진이 실행 전에 스코프와 변수 관계를 미리 파악(컴파일)해야만 가능한 일이다.

### 1.4 컴파일러체

JS 엔진이 변수를 어떻게 식별하고 스코프를 결정하는지 알아본다.

### 1.4.1 할당의 타깃 (LHS : Left-Hand Side)

값을 **할당받는** 변수는 타깃이다.

```jsx
students = [ // ... ]  // students는 타깃
nextStudent = getStudentName(73)  // nextStudent는 타깃
for (let student of students) {  // student는 타깃
```

### 1.4.2 값의 소스 (RHS : Right-Hand Side)

값을 **꺼내 쓰는** 변수는 소스(RHS)다.

```jsx
for (let student of students) {  // students는 소스
    if (student.id == studentID) {  // student, studentID는 소스
        return student.name;  // student는 소스
```

모든 변수 참조는 타깃(할당받음) 아니면 소스(값 꺼냄) 둘 중 하나다.

### 1.5 런타임에 스코프 변경하기

eval()쓰지말자

### 1.6 렉시컬 스코프

JS의 스코프는 컴파일 타임에 결정되는 **렉시컬 스코프**다. 함수나 블록, 변수 선언의 스코프는 코드 배치에 따라 결정된다.

함수 안에 변수를 선언하면 컴파일러는 해당 변수를 함수의 스코프와 연결한다. `let`/`const`로 선언하면 블록 스코프, `var`로 선언하면 함수 스코프다.

변수 참조(타깃/소스)는 해당 변수가 **렉시컬적으로 사용 가능한** 여러 스코프 중 하나에서 결정된다. 변수가 현재 스코프에 없으면 다음 외부(감싸는) 스코프를 찾는다.

컴파일 중에는 스코프를 식별하기만 하고, 실제 각 스코프를 실행하는 건 런타임 전까지는 생성되지 않는다. 런타임에 사용할 코드가 들어간 계획만 만들어진다.

렉시컬 환경(environment)이란 스코프가 전부 정의되고 각 스코프에 해당하는 식별자(변수)가 추가된 것을 말한다.

컴파일 중에는 스코프를 식별하기만 하고 실제 각 스코프를 실행해야 하는 런타임 전까지는 스코프가 생성되지 않는다.
