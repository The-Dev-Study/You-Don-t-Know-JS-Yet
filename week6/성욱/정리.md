## 스코프

### 1.1 책에 대하여

JS는 일반적으로 스크립트 언어로 분류.

그런데 실제 JS는 실행 전 별도의 단계에서 파싱, 컴파일이 일어난다.

개발자가 지정한 변수, 함수, 블록의 위치는 파싱, 컴파일 단계에서 스코프 규칙에 따라 분석되고

그 결과에 따라 결정된 스코프 구조는 대개 런타임 조건에 영향을 받지 않는다.

JS에서 함수는 일급값이기 때문에 함수를 변수에 할당해 다른 곳으로 넘기는 것이 가능하다.

해당 변수에 접근하기 위해 함수를 정의할 때 결정된 스코프를 유지해야하는데 이를 클로저라고 한다.

### 1.2 컴파일 vs 인터프리트

컴파일레이션은 텍스트 형식으로 작성한 코드를 처리해서 컴퓨터가 이해할 수 있는 작업 지시 목록으로 바꾸는 과정이다.

이 과정을 거치면 보통 한번에 소스 코드가 변환되는데, 변환 결과는 추후 실행 가능한 형태로 저장된다.(주로 파일 형태)

인터프리테이션은 개발자가 작성한 프로그램을 기계가 해석할 수 있는 명령으로 변환한다. 컴파일과 유사하지만 처리 방식이 다르다.

컴파일레이션은 프로그램을 한번에 처리하는 반면 인터프리테이션은 소스 코드를 한줄씩 변환한다.

최신 JS 엔진은 프로그램을 처리할 떄 수많은 종류의 컴파일레이션과 인터프리테이션을 사용한다.

1부에서의 결론은 `JS는 컴파일 언어라 표현하는게 정확하다`였다.

### 1.3 코드 컴파일

컴파일러 이론에서는 프로그램이 컴팡일러의 다음 세 가지 주요 단게를 거쳐 처리된다고 정의한다.

1단계: 토크나이징/렉싱

문자열을 토큰이라는 의미 있는 조각으로 쪼갠다. 무상태 방식 - 토크나이징, 상태 유지 방식 - 렉싱

2단계: 파싱

토큰 배열을 프로그램 문법 구조를 반영하는 중첩 원소 기반의 트리인 AST(추상 구문 트리)로 바꾼다.

3단계: 코드 생성

AST를 컴퓨터가 실행 가능한 코드로 변환한다.


실제 JS 엔진은 훨씬 복잡하게 동작하며 파싱과 코드 단계에서 최적화가 진행된다.

### 1.3.1 필수 두 단계

중점으로 봐야할 것은 프로그램 처리가 파싱과 컴파일이 먼저 일어나고 그 다음 실행이 된다는 것이다.

ECMA 명세서에 `선 컴파일 후 실행` 접근 방식을 취하지 않으면 명세서에서 요구하는 동작을 충족할 수 없다고 나온다.

이 방식을 입증하는 JS 특징은 구문 오류, 초기 오류, 호이스팅이 있다.

- 구문 오류

```
var greeting = "안녕하세요.";
console.log(greeting);
greeting = ."안녕!"; // SyntaxError
```

한줄씩 실행된다면 greeting이 출력되어야하지만 오류가 발생한다. 파싱을 먼저 한다는 증거다.

- 초기 오류

```
console.log("잘 지내시죠?");
saySomething("안녕하세요.", "안녕!"); // Uncaught SyntaxError: Duplicate ...

function saySomething(greeting, greeting) {
	"use strict";
	console.log(greeting);
}
```

첫째 줄에 문제가 없는데 메시지 출력이 되지 안흔ㄴ다.

오류가 발생한 이유는 엄격모드 때문인데, 엄격 모드에서는 이름이 같은 함수 매개변수가 허용되지 않기 때문이다.

JS 엔진이 이러한 초기 오류를 잡기 위해서는 파싱이 전제된다는 가정만이 이러한 현상을 설명할 수 있다.

- 호이스팅

마찬가지로 프로그램이 실행되기 전 파싱이 이뤄져야지 이런 스코프 선언에 관한 처리가 정확하게 알 수 있는 것이다.

let과 const가 호이스팅이 일어나지 않는다는 것은 잘못된 정보이고, 너무 빨리 변수에 접근하려하는 TDZ의 개념이다.

### 1.4 컴파일러체

선언을 제외하고 프로그램 내 모든 변수와 식별자는 할당의 타깃이나 값의 소스, 둘 중 하나의 역할을 한다.

LHS(left-hand side), RHS(right-hand side)

const A = "Hi" 에서 왼쪽이 타깃, 오른쪽이 값

### 1.4.1 할당의 타깃

`students = [ // ...]`, `nextStudent = getStudentName(73)`, `for (let student of students)`, `getStudentName(73)`

`function 키워드`로 선언한 함수 선언은 타깃 참조의 특수한 케이스다.

할당문이 실행될 떄 설정되는게 아닌 스코프가 구성되기 시작하는 시점에 자동으로 설정된다.

### 1.4.2 값의 소스

`for (let student of students)`에서 students는 소스 참조. 조건문 `if (student.id == studentID)`에서 student와 studentID는 둘 다 소스 참조.

`getStudentName(73)`에서 getStudentName은 함수 참좃값의 소스 참조.

`console.log(nextStudent)`에서 console, nextStudent는 소스 참조.

### 1.5 런타임에 스코프 변경하기

스코프는 컴파일 때 결정되고 런타임 환경에 영향을 받지 않는다.

하지만 비엄격 모드에서는 이 규칙을 깰 수 있고(스코프 수정 가능) 이를 사용해서는 안된다.

1. eval()

2. with()

### 1.6 렉시컬 스코프

컴파일 타임에 결정되는 스코프를 렉시컬 스코프(어휘 스코프)라고 한다. 이는 컴파일레이션 세 단계 주 렉싱과 관련이 있다.

핵심은 함수나 블록, 변수 선언의 스코프는 전적으로 코드 배치에 따라 제한된다는 점이다.

