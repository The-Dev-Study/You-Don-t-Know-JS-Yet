# 1.5.2 간극을 메우기 위한 방법 찾기
상위 호환성 문제가 새로운 문법이 아닌 근래에 추가되었지만, 아직 지원하지 않는 API 메서드 때문에 발생했다면, 메서드 정의를 추가해 이미 이 메서드가 오래된 환경에도 있었던 것 처럼 해주는 방법이 가장 일반적인 해결책이다. 이런 패턴을 폴리필(일명 심)이라고 한다. 예시를 살펴보자

``` js
// getSomeRecords()는 원격으로 가져온 데이터를 담은 프로미스를 반환합니다.
var pr = getSomeRecords();

// 데이터를 가져오는 동안 화면에 스피너를 보여줍니다.
startSpinner();

pr
.then(renderRecords) // 가져온 데이터를 화면에 표시합니다.
.catch(showError) // 데이터를 가져오는 데 실패했다면 오류가 발생합니다.
.finally(hideSpinner) // 성공과 실패 여부와는 상관없이 마지막엔 스피너를 숨깁니다.
```
예시서는 ES2019의 프로미스 프로토타입에 푸가된 finally() 메서드를 사용한다. 이 예시를 ES2019를 지원하지 않는 환경에서 실행하면 finally()가 존재하지 않으므로 오류가 발생한다.

ES2019를 지원하지 않는 환경에서 finally()를 사용하려면 다음과 같은 폴리필이 필요하다.
``` js
if (!Promise.prototype.finally) {
    Promise.prototype.finally = function f(fn) {
        return this.then(
            function t(v){
                return Promise.resolve( fn() )
                        .then(function t() {
                            return v;
                        });
            },
            function c(e) {
                return Promise.resolve( fn() )
                        .then( function t() {
                            throw e;
                        });
            }
        );
    };
}
```

| 예시용 코드일 뿐이다.

JS 엔진에 finally 메서드가 구현되어 있다면 if 문에서 막히면서 폴리필이 작동하지 않는다. 오래된 실행 환경에서는 새롭게 정의된 폴리필이 작동하지만 비교적 새로운 실행 환경에서는 if 문을 뛰어넘는다.

바벨과 같은 트랜스파일러는 개발자가 작성한 코드 중 폴리필이 필요한 코드를 찾아내고 자동으로 폴리필을 추가한다. 종종 개발자가 명시적으로 폴리필을 추가해야 할 때도 있는데 그런 경우라면 앞선 예시와 유사한 형태로 작성하면 된다.

트랜스파일이나 폴리필은 오래된 환경이나 애플리케이션, JS 최신 기능 이 둘 사이의 간극을 메꾸는 가교 역할을 한다. 