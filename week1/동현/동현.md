# 유돈노jsyet

### 1.1 책에 대해서

자바스크립트는 정복 못한다.. 인내와 끈기를 가지고 자세히 보자 두번세번봐서 제대로 이해하자

### 1.2 자바스크립트 이름의 유래

ECMAscript가 공식 명칭이며 당연하게도 자바와 자바스크립트는 아무 관계가 없다

### 1.3 명세서

TC39 위원회라는곳에서 JS의 공식 명세를 관리한다

정기 모임에서 안건을 투표하고, 합의해 국제 표준화 기구인 ECMA에 제출한다

여기서 정해진 명세대로 모든 브라우저의 엔진이 동작한다

### 1.3.1 JS를 지배하는 웹

JS런타임은 브라우저외에도 많다 서버, 로봇, 전구(?)까지

다만 가장 큰 비중인 분야는 웹이므로 브라우저 환경을 가장 중요하게 고려해야 한다

명세서 개정 시 기존 동작과 불일치 되는 경우가 생기는데 TC39가 명세를 웹에 맞춘다.

Array메서드 contains() → includes(), flatten() → flat() 변경 사례 존재

### 1.3.2 JS지만 JS가 아닌 웹 전용 문법

alert(), console.log(), fetch() 등등… 는 명세서에 없다

다만 브라우저, node.js 환경에선 전역 스코프에 해당 api를 추가한다

### 1.3.3 모든 코드가 JS인 것은 아닙니다

개발자도구/콘솔을 완벽히 신뢰해선 안된다. 항상 JS의 처리 방식을 엄격하게 준수하지 않는다

### 1.4 JS의 다양한 얼굴

JS는 멀티 패러다임 언어로 절차적/객체지향/함수형을 모두 지원한다.

### 1.5 하위 호환성과 상위 호환성

하위호환성: 명세서에 있던 문법이면 레거시 엔진에서 실행 가능

상위호환성: 새로 명세서에 추가된 문법이 레거시 엔진에서 호환

JS는 하위호환성O 상위호환성X

즉 구버전 레거시는 실행 가능하지만  신버전 문법 사용 불가

### 1.5.1 간극을 줄이기 위한 노력

상위 호환성을 위해 트랜스파일러(ex. babel)을 사용한다.

트랜스파일러는 스코프기반 변수인 let을 var로 변환해서 같은 동작하게 변환하듯이 최신 문법을 이전 문법으로 호환 가능하도록 변경해준다

### 1.5.2 간극을 메우기 위한 방법 찾기

최신 문법을 사용하기 위해 메서드를 새로 정의해 사용 가능하게 하는 패턴을 폴리필이라 한다.

트랜스파일러는 폴리필이 필요한 코드를 찾아내 추가한다

### 1.6 인터프리터 이해하기

JS는 컴파일 언어에 더 가깝다

JS는 파싱 뒤 인터프리터 언어처럼 한줄 한줄 실행되지 않고 최적화된 이진 코드로 변환되어 실행된다

[JS코드] (파싱) [AST트리] (컴파일) [이진코드] (실행) [결과물]

자세히 설명하면

1. 트랜스파일링, 번들링해 JS엔진에 전달
2. JS엔진이 파싱해 AST로 변경
3. JS엔진이 AST를 이진코드로 변경 동시에 JIT 컴파일러가 작동해 최적화가 함께 진행됨
4. JS 가상머신이 실행

### 1.6.1 웹어셈블리

웹어셈블리는 실행 전 단계인 파싱과 컴파일을 거치지 않아 지연을 피한다

타 언어 포팅하는 역할

필자는 웹어셈블리가 JS를 대체하지 못한다고 서술

### 1.7 엄격 모드

매우 빡센 린터라 생각하면 된다.

‘use strict’는 파일단위, 함수단위로 적용 가능

### 1.8 정리

- JS는 브라우저 node.js등 다양한 환경에서 실행 가능하다
- JS는 멀티패러다임 언어이다
- JS는 컴파일 처리되는 언어이다

### 소감

JS가 컴파일된다 할때 정확히 이해하지 못해 대충 넘어갔었는데 개념을 정확히 할 수 있었다.

이펙티브 타입스크립트에 비해 기대치가 낮았는데 모르는 부분 설명이 명확히 되어있어 생각보다 많이 얻어갈 수 있을 것 같다.
