# 1주차 정리

## JavaScript는 컴파일 언어인가?

**결론: JavaScript는 컴파일 언어에 가깝다.**

JavaScript는 소스 코드를 배포하지만, 실행 전에 다음과 같은 과정을 거친다:

1. **파싱**: JS 엔진이 코드를 파싱해 AST(추상 구문 트리)로 변환
2. **컴파일**: AST를 이진 바이트 코드로 변환 (JIT 컴파일러가 최적화 수행)
3. **실행**: JS 가상 머신이 프로그램 실행

모든 컴파일 언어는 파싱을 거치며, 파싱 후 실행 가능한 코드를 생성하는 과정까지 수행하므로 JavaScript도 컴파일 언어로 볼 수 있다.

> **참고**: MDN에서는 "가벼운 인터프리터 언어"라고 하지만, 실제로는 JIT 컴파일을 통해 이진 코드로 변환되어 실행되므로 컴파일 언어의 특성을 가진다.

## 하위 호환성과 상위 호환성

### 하위 호환성

- 한 번 유효한 JS는 영원히 유효함
- 과거에 작성된 코드가 새 브라우저에서도 동작함
- JS는 하위 호환성을 보장함

### 상위 호환성

- JS는 상위 호환성을 보장하지 않음
- 새 문법은 구형 브라우저에서 작동하지 않음

### 해결 방법

**트랜스파일 (Transpile)**

- 구 엔진과 호환되지 않는 새 문법을 구 문법으로 변환
- 예: `let` → `var` 변환
- 주로 Babel 사용

**폴리필 (Polyfill)**

- 구 엔진에서 지원하지 않는 API를 구현해서 추가
- 예: `Promise.prototype.finally` 같은 메서드
- 트랜스파일러가 자동으로 필요한 폴리필 추가

## 웹 전용 문법 (`1.3.2 JS지만 JS가 아닌 웹 전용 문법`)

`alert()`, `console.log()`, `fetch()` 등은 **ECMAScript 명세에 없는 브라우저 API**이다.

- JS 실행 환경(브라우저, Node.js)이 전역 스코프에 추가한 API 기능
- `console.log` 동작이 웹 브라우저마다 다를 수 있음
- 개발자 도구는 JS를 항상 엄격하게 준수하지 않으므로, 콘솔 결과를 완전히 신뢰하지 말 것

## WebAssembly와 멀티스레딩

**질문**: Wasm으로 멀티스레딩? 애초에 JS는 싱글 스레드이기 때문에 이해가 안된다.

**답변**:

JavaScript 자체는 싱글 스레드이지만, WebAssembly를 통해 멀티스레딩을 활용할 수 있다:

1. **WebAssembly Threads**: WebAssembly는 `SharedArrayBuffer`와 Web Workers를 통해 멀티스레딩을 지원
2. **다른 언어 활용**: Go, Rust, C++ 등 멀티스레딩을 지원하는 언어로 작성한 코드를 Wasm으로 컴파일하여 실행
3. **JS 엔진에서 실행**: Wasm 모듈은 JS 엔진에서 실행되지만, JS 언어 자체가 스레드를 지원하지 않아도 Wasm 레벨에서 멀티스레딩 가능

> **참고**: Wasm은 JS를 대체하기 위한 것이 아니라, 웹에서 할 수 있는 것들을 확장하는 역할을 수행한다.

## React StrictMode vs use strict

**질문**: 리액트 strict mode와 use strict는 같은건지?

**답변**: **다르다.**

### `use strict` (JavaScript 엄격 모드)

- JavaScript 언어 자체의 엄격 모드
- 파일 단위 또는 함수 단위로 적용
- JS 엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 돕는 모드
- 초기 오류(컴파일 단계에서 잡을 수 있는 오류)를 활성화
- 예: 중복된 매개변수 이름, `this` 바인딩 오류 등

### `React.StrictMode` (React 개발 모드)

- React의 개발 모드 기능
- 컴포넌트의 잠재적인 문제를 찾아내기 위한 도구
- 개발 환경에서만 동작하며, 프로덕션 빌드에는 영향 없음
- 다음을 검사:
  - 안전하지 않은 생명주기 메서드 사용
  - 레거시 문자열 ref API 사용
  - 권장되지 않는 findDOMNode 사용
  - 예상치 못한 부작용 감지
  - 레거시 Context API 사용

**결론**: `use strict`는 JavaScript 언어 레벨의 엄격 모드이고, `React.StrictMode`는 React 컴포넌트 레벨의 개발 도구이다.

## Linter vs use strict vs TypeScript

**질문**: linter, use strict, typescript 어떻게 다른지?

### Linter (예: ESLint)

- **목적**: 코드 스타일과 잠재적 버그를 찾아주는 정적 분석 도구
- **기능**:
  - 팀 컨벤션 맞추기 (코드 스타일 통일)
  - 잠재적 버그 발견 (사용하지 않는 변수, 잘못된 문법 등)
  - 코드 품질 향상
- **실행 시점**: 개발 중 (에디터에서 실시간 체크) 또는 빌드 시
- **타입 체크**: 하지 않음 (일부 플러그인으로 가능)

### `use strict` (JavaScript 엄격 모드)

- **목적**: JavaScript 엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 돕는 모드
- **기능**:
  - 초기 오류 활성화 (컴파일 단계에서 잡을 수 있는 오류)
  - 런타임 오류 감지 (예: `this` 바인딩 오류)
  - 더 엄격한 문법 검사
- **실행 시점**: 런타임
- **타입 체크**: 하지 않음

### TypeScript

- **목적**: JavaScript에 정적 타입 시스템을 추가한 언어
- **기능**:
  - 타입 안정성 제공
  - 컴파일 타임에 타입 오류 검사
  - 자동완성 및 리팩토링 지원
  - JavaScript로 트랜스파일
- **실행 시점**: 컴파일 타임 (TypeScript → JavaScript 변환 시)
- **타입 체크**: 핵심 기능

### 비교표

| 도구           | 실행 시점       | 타입 체크 | 코드 스타일 | 목적                      |
| -------------- | --------------- | --------- | ----------- | ------------------------- |
| **Linter**     | 개발 중/빌드 시 | ❌        | ✅          | 코드 품질, 컨벤션         |
| **use strict** | 런타임          | ❌        | ❌          | JS 엔진 최적화, 오류 감지 |
| **TypeScript** | 컴파일 타임     | ✅        | ❌          | 타입 안정성               |

**결론**:

- **Linter**: 코드 스타일과 잠재적 버그를 찾는 도구
- **use strict**: JS 엔진 최적화를 위한 언어 레벨의 엄격 모드
- **TypeScript**: 타입 안정성을 제공하는 정적 타입 언어

## 프로그래밍 패러다임

JavaScript는 **다중 패러다임 언어**로, 여러 패러다임을 지원한다.

### 객체지향 프로그래밍 (OOP)

- 각자 역할 분리해서 캡슐화
- 클래스를 기준으로 코드 구조화
- 로직과 데이터를 클래스에 정의

### 함수형 프로그래밍

- 변화에 유연하다
- 부수 효과가 없는 순수 함수 단위로 코드 구조화
- 함수 자체가 값으로 취급됨
- 예: `lodash.flow()` - 함수 합성

### 절차적 프로그래밍

- 코드가 톱다운/선형적으로 구조화
- 프로시저 단위로 일련의 연산 작성

**결론**: 상황에 맞게 적절한 패러다임을 선택하여 사용하면 된다.

## 인터프리터 언어인가?

**결론**: JavaScript는 컴파일 언어의 특성을 가지지만, 전통적인 의미의 인터프리터 언어로도 볼 수 있다. 브라우저 동작 과정에 컴파일 과정이 있기 때문이다.

- **컴파일 측면**: 파싱 → AST → 이진 바이트 코드 변환 (JIT 컴파일)
- **인터프리터 측면**: 소스 코드를 직접 배포하고, 브라우저에서 동작
- **MDN**: "가벼운 인터프리터 언어"라고 명시

실제로는 JIT(Just-In-Time) 컴파일을 통해 이진 코드로 변환되어 실행되므로, 컴파일 언어의 특성을 가진다.
