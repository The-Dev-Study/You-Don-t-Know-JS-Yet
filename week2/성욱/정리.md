## 2 자바스크립트 조망하기

### 2.1 파일은 프로그램입니다

JS에서는 파일 각각이 별도의 프로그램이다

파일 각각을 프로그램으로 봐야 하는 중요한 이유는 주로 오류 처리와 관련 있다

JS는 파일을 프로그램으로 취급하기 때문에 파일 하나에만 오류가 있어도 다음 파일이 처리되지 않을 수 있다

독립적인 .js 파일 여러개를 작동시키는 유일한 방법은 **전역 스코프**를 사용해 파일 간 상태를 공유하고, 공통으로 사용하는 기능을 접근할 수 있도록 만드는 방법뿐이다

ES6 이후로 독립형(standalone) 포맷 외에 모듈 포맷도 지원하는데 모듈도 파일 기반이다

파일 하나를 **고유한 작은 프로그램**이라고 생각해야 한다

### 2.2 값

프로그램에서 정보의 가장 기본적인 단위는 값이고 값에는 데이터가 저장된다

JS에서는 값은 크게 **원시 타입**과 **객체 타입**으로 분류된다

백틱에는 문자열 내 변수 표현식을 출력할 수 있는 기능이 있다

이런 방식을 보간법(interpolation)이라 한다

일관성을 유지하는게 좋다 ("", '', `${}`)

null, undefined 구분 잘 할 것

symbol - 사람이 추측할 수 없게 만든 특수한 숨김 값. 심벌은 객체에서 특정한 키를 만들 때 주로 사용한다 (대개 라이브러리나 프레임워크 같은 저차원 코드에서 사용)

### 2.2.1 배열과 객체

배열에는 원시타입, 객체 타입 상관없이 모든 타입의 값이 들어갈 수 있다. 함수 역시 할당 가능 (함수 또한 객체의 한 종류)

객체는 배열보다 좀 더 일반적인 타입으로 정렬되지 않은 키-값 쌍을 모아놓은 컬렉션.

### 2.2.2 값의 타입

```javascript
typeof 42;									// "number"
typeof "abc";								// "string"
typeof true;								// "boolean"
typeof undefined						// "undefined"
typeof null;								// "object" <- bug
typeof { "a": 1 };					// "object"
typeof [1, 2, 3];						// "object"
typeof function hello(){};	// "function"
```


타입을 변경하는 것을 타입 강제 변환(coercion)이라고 한다

변수에 할당하거나 어딘가에 넘길 때 원시값과 객체의 작동 방식은 차이가 있다

### 2.3 변수 선언과 사용

var - 접근 범위 함수 스코프

let - 접근 범위 블록 스코프

const - let과 유사, 값을 재할당할 수 없음

const가 객체로 선언되면 그 안의 내용을 바꿀 수 있어 혼란이 발생하기 때문에 const를 사용해 객체를 정의하는건 피하도록 하자

### 2.4 함수

함수라는 단어에는 다양한 의미가 있다

함수형 프로그래밍 패러다임에서는 함수가 수학적 정의를 가지고 있으며 준수해야 할 엄격한 규칙의 집합을 의미한다

JS로 개발할 때 함수보다 좀 더 포괄적인 개념인 '프로시저'를 프로그램에 녹여내기 위해 심사숙고하며 함수를 작성해야 한다

프로시저는 한 번 이상 호출할 수 있고 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음을 의미한다

함수 선언문, 함수 표현식

JS에서 함수는 할당 가능하고 어디든 전달 가능한 값이라는 특징이 매우 중요하다

### 2.5 비교

프로그램은 값을 비교해 값의 정체와 값 사이의 관계를 파악한 후 의사 결정을 내린다

### 2.5.1 같음에 대한 고찰

일치 비교(equality comparison)와 등등 비교(equivalence comparison)의 차이

예상과 다르게 동작하는 경우

```javascript
NaN === NaN // false
0 === -0;		// true
```

Number.isNaN(), Object.is()를 사용해야 정확하게 비교할 수 있다

=== 연산자만으로는 `아주 정확하게` 비교를 할 수 `없다`

원시 타입이 아닌 객체끼리 비교할 때

```javascript
[1, 2, 3] === [1, 2, 3] // false
{ a: 42 } === { a: 42 } // false
(x => x * 2) === (x => x * 2) // false
```

일치 비교는 값의 본질이나 내용을 비교한다

비교 대상이 객체인 경우, 값의 본질이나 내용이 아닌 구조적 일치를 비교하게 된다

객체끼리 비교할 때 비교 연산자가 구조적 일치를 판단하지 않고 독자성 일치를 비교한다

독자성 일치? - identity equality(동일성)

### 2.5.2 강제 변환

강제 변환 - 한 타입의 값이 다른 타입의 값으로 변하는 걸 의미

강제 변환, 일치 연산자 동시에 고려해야하면 혼란이 가중된다

== 연산자는 === 연산자와 유사한 방식으로 피연산자가 같은지 비교한다. 만약 같은 타입이라면 어떠한 차이도 없이 완전히 동일하게 작동한다.

그런데 타입이 다른 경우 == 연산자는 강제로 타입을 맞추는 작업을 수행한다. 이 점에서 == 연산자는 **강제 변환 동등 비교 연산자** 이다

타입 강제 변환이 수반되는 비교는 if 등의 조건문에서도 나타난다

### 2.6 코드 구조화 패턴

1. 클래스
2. 모듈

이들은 상호 배타적인 패턴이 아니다. 많은 프로그램이 두 패턴을 모두 사용하고 하나만 사용하거나 두 패턴 모두 사용하지 않는 프로그램도 있다.

### 2.6.1 클래스

사용자가 정의한 데이터 타입으로 데이터와 이 데이터를 조작하는 동작이 들어간다.

어떻게 동작하는지 정의하긴 하지만 구체적인 값은 아니다.

프로그램에서 사용할 수 있는 구체적인 값이 필요하다면 new 키워드를 사용해 인스턴스를 만들어야 한다.

클래스 지향 설계는 상속과 다형성을 생각해야 한다

상속받은 메서드와 새롭게 정의한 메서드의 이름이 동일하고 공존할 수 있는 걸 다형성이라고 한다

상속은 클래스라는 독립된 논리적 공간에 데이터와 행동을 체계화할 수 있도록 만드는 강력한 도구다. 자식 클래스는 부모 클래스의 데이터나 동작에 접근하거나 사용하는 방식으로 부모 클래스와 협력한다.

### 2.6.2 모듈

클래스와 마찬가지로 논리적 단위 기준으로 데이터와 행동을 그룹화하는데 목적이 있다. 차이는 문법에 있다.


**클래식 모듈**

최소 한 번 이상 실행되는 외부 함수가 특징으로 외부 함수는 모듈 인스턴스 내부의 숨겨진 데이터를 대상으로 작동하는 함수가 있는 '인스턴스'를 반환한다


**ES 모듈**

구현 관점에서 ES 모듈과 클래식 모듈의 접근법에는 큰 차이가 있다.

1. ES 모듈에는 모듈을 정의하는 래핑 함수가 없다. 항상 파일 기반이고 하나의 파일은 모듈 하나다.
2. ES 모듈을 사용할 때 모듈 API와 직접 상호작용하지 않는다. export 키워드가 붙어있지 않으면 클래식 모듈처럼 숨김 상태가 된다
3. ES 모듈을 인스턴스화하지 않아도 import 키워드를 사용해 가져오기만 하면 단일 인스턴스처럼 사용할 수 있다. 모듈을 가져온 순간 인스턴스가 생기고 동일한 모듈을 다른 곳에서 import할 때는 이미 생성된 모듈의 참조만 가져온다. (사실상 싱글톤)

ES 모듈 내부에 클래식 모듈을 함께 사용하면 모듈 인스턴스를 여러개 만들 수 있다.