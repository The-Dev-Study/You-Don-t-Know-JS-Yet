### 2.1 파일은 프로그램입니다

JS는 파일 각각이 **고유한 작은 프로그램**이다

5개 파일중 하나라도 에러가 있으면 전체 애플리케이션이 터집니다..

> 이게 둘이 같은 이야기가 맞는지 표현이 좀 애매한것 같다. 하나의 애플리케이션이니까 하나라도 문제가 생기면 터지는거 아닌가..?
>

> utils.js가 있다 하면 이 모듈은 다른곳에서도 독립적으로 사용이 가능하니 프로그램이다 라는 의미인가
>

독립적인 .js 파일 여러개를 하나로 모으기 위해 유일한 방법인 전역 스코프를 사용한다

### 2.2 값

JS에선 원시 타입과 객체 타입이 있다

보간법(템플릿 리터럴) 사용이 아닐땐 백틱 사용을 지양하자

null대신 undefined를 사용하자

여기도 심벌의 적절한 사용 예시는 나오지 않는다.

> 심벌은 직렬화 불가능한 원시타입으로 클라이언트 내부에서 고유 키를 만들때 써먹는다 → 라이브러리 만들꺼 아니면 쓸 일이 없어보인다
>

### 2.2.1 배열과 객체

배열엔 모든 원시타입, 객체타입, 함수 모두 할당 가능하다

### 2.2.2 값의 타입

typeof 연산자를 사용해 js타입(런타임에도 유효한 원시/객체 타입) 반환이 가능하다

```jsx
// warning
typeof [1,2] // "object"
typeof null // "object"
typeof function hello(){}  // “function”
```

### 2.3 변수 선언과 사용

var는 함수 스코프 단위, let, const는 렉시컬 스코프 단위로 살아있다.

함수 인자로 넘길때 var로 선언한 것처럼 작동한다 ← 조금 위험한 설명 같아 아래 예시 추가

> 혹시 call by ref와 call by value에 대해 정확히 알고 계신가요?
>

> 함수 인자로 object를 넘길땐 참조 자체를 넘긴것처럼 동작한다.
>

```jsx
function add(target){
	target.count += 1;
}

let a = {count: 1}
add(a)
console.log(a) // {count : 2}

function reassign(target) {
  target = { count: 999 };
}

let b = { count: 1 };
reassign(b);
console.log(b);  // { count: 1 } 기존 메모리 주소는 영향받지 않았음
```

> 원시타입은 call by value이므로 당연히 함수 내부 변경에 영향받지 않는다
>

```jsx
function addPrimitive(num) {
  num += 1;
}

let x = 1;
addPrimitive(x);
console.log(x);  // 1 - 변경되지 않음
```

### 2.4 함수

함수형 프로그래밍에서의 함수 : 정확한 수학적 정의를 가지고 있으며 준수해야 할 엄격한 규칙의 집합

> 당연한 소리아닌가? 어떤 개념을 전달하고 싶은지 모르겠다
>

프로시저 : 한 번 이상 호출할 수 있고 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음

> 찾아봐도 현대 언어에서 함수랑 다른점이 없어보인다.
>

> RPC(Remote Procedure Call)에서 등장하던 용어이다.  RPC의 목표는 네트워크 통신의 복잡성을 추상화하여 분산 및 네트워크 애플리케이션을 만드는 과정을 단순화하는 것.
>

> 단순히 프로토콜을 커스텀해 암호화, 효율화해 사용하는데 의의가 있는줄 알았는데 (ex. gRPC) 추상화가 메인인듯
>

함수 표현식을 통해 ref를 변수에 담을 수 있다 like 함수포인터

### 2.5.1 같음에 대한 고찰

일치 비교 === : 값, 타입 동등

동등 비교 == : 값 동등

> ref인지 value인지 파악만 잘 하고 있으면 헷갈릴 일 없다
>

### 2.5.2 강제 변환

동등 비교 기능에 대한 카일 심슨의 분노

### 2.6.1 클래스

다형성에 대한 설명

### 2.6.2 모듈

new 없이 함수 내부에서 객체를 만들어 내보내는 생성자와 유사한 방식을 **모듈 팩토리**라 부른다

> ES 모듈에 대한 설명이 좀 이상하다
>

**책의 예시 :**

**publication.js**

```jsx
export function create(title, author, pubDate) {
  var publicAPI = {
    print() {
      printDetails(title, author, pubDate);
    }
  };
  return publicAPI;  // 새 객체를 반환
}

```

**blogpost.js**

```jsx
import { create as createPub } from "publication.js";

export function create(title, author, pubDate, URL) {
  var pub = createPub(title, author, pubDate);  // 새 인스턴스 생성

  var publicAPI = {
    print() {
      printDetails(pub, URL);
    }
  };
  return publicAPI;  // 또 다른 새 객체 반환
}

```

**main.js**

```jsx
import { create as newBlogPost } from "blogpost.js";

var forAgainstLet = newBlogPost(...);  // 여기서만 인스턴스 생성
forAgainstLet.print();

```

**책의 설명 : 예시에서 살펴본 것처럼 ES 모듈 내부에 클래식 모듈을 함께 사용하면 모듈 인스턴스를 여러 개 만들 수 있습니다**

> 모듈 인스턴스 ← 이게 인스턴스랑 다른건가?
>

> 저 nesting되는 팩토리함수가 main.js에서 실행 될때 그때 순서대로 실행되는거지 저 모듈별로 인스턴스가 존재하는게 아니지 않나 싶음
>

> 아니면 걍 번역이 잘못된거 같기도?
>

오번역임

As shown, ES modules can use classic modules internally if they need to support multiple-instantiation. Alternatively, we could have exposed a class from our module instead of a create(..) factory function, with generally the same outcome.
