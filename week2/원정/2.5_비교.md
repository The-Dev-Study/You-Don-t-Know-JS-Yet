# 2.5 비교
JS에서는 '값 X가 값 Y와 같을까?'라는 비교를 가장 많이 한다. 그럼 이 질문에서 같다란 무엇일까?

여러가지 이유로 JS에서 서로 다르지 않음은 사전적 의미보다 좀 더 복잡하다.
JS에서 같음을 비교할 떄는 정확하게 일치하는지를 따지기도 하지만 때로는 아주 유사하다거나 교환 가능한지와 같이 좀 더 넓은 관점에서 비교하는 때도 있다. 그렇기 때문에 일치 비교와 동등 비교의 차이를 알고있어야 한다.

> 사람들은 종종 일치 연산자(===)는 '값과 타입의 둘 다의 동등성을 확인'한다고 표현한다. 그런데 사실 비교는 좀 더 심호하다. JS에서 비교가 일어날 때는 일치 연산자에서처럼 타입도 고려된다. 일치 동등 비교와 다른 비교 연산이 다른 점은 일치, 동등 비교에서는 타입 강제 변환을 허용하지 않지만, 다른 비교 연산에서는 타입 강제 변환을 허용한다는 차이가 있다.

그런데 === 연산자가 특수한 값인 NaN이나 -0과 함께 사용되면 예상과 다르게 작동한다.
``` js
NaN === NaN; // false
0 === -0; // true
```

NaN을 만나면 === 연산자는 거짓말을 한다. NaN과 또 다른 NaN은 같지 않다고 말이다. -0을 만나도 마찬가지이다. -0과 0은 다르지만 ===은 이 둘이 같다고 거짓말을 한다.

이런 거짓말을 다루는 건 꽤나 성가신 일이다. 그러니 === 연산자는 NaN이나 -0과 함께 쓰지 않는게 최선이다. NaN과 비교할 때는 거짓말을 하지 않는 Number.isNaN()을 사용하고, -0과 비교할 때는 Object.is()를 사용하라. 아주 정직한 메서드인 Object.is()도 NaN과 비교할 때 사용할 수 있으니 선호에 따라 하나를 택해 사용하면 된다.

=== 연산자가 거짓말을 하는데는 역사적, 기술적 이유가 있지만, 어쨌든 결론은 === 연산자만으로는 아주 정확하게 비교를 할 수 없다는 사실이다.

한편, 원시 타입이 아닌 객체끼리 비교할 때는 상황이 조금 더 복잡해진다.
``` js
[1, 2, 3] === [1, 2, 3] // false
{ a: 42 } === { a: 42 } // false
(x => x * 2) === (x => x * 2) // false
```

일치 비교는 값의 본질이나 내용을 비교한다고 볼 수 있다. 42 === 42 같은 코드에서는 실제 숫자인 42끼리 비교가 일어난다. 그런데 비교 대상이 객체인 경우에는 값의 본질이나 내용이 아닌 구조적 일치를 비교하게 된다.

JS에서는 객체끼리 비교할 때 비교 연산자가 구조적 일치를 판단하지 않는다. 대신 독자성 일치(identity equality)를 비교한다.

JS에서 객체는 참조에 의해 고정되며 참조 복사본을 사용해 할당, 전달된다. 그리고 참조(독자성)를 대상으로 일치 비교가 일어난다. 예시를 살펴보자.

``` js
var x = [1, 2, 3];

// 참조를 복사한 값이 할당되기 때문에 변수 y는 x의 복사본이 아니다.
// 변수 y는 x와 같은 배열을 참조한다.
var y = x;

y === x; // true;
y === [1, 2, 3]; // false
x === [1, 2, 3]; // false
```

예시에서 y === x는 변수 y와 x가 모두 같은 배열에 대한 참조를 담고 있으므로 true를 반환한다. 하지만 그 아랫줄의 === [1, 2, 3] 비교에서는 변수 y와 x 둘다 각각 새로운 배열 [1, 2, 3]과 비교가 일어나기 때문에 false를 반환한다. 예시에서 배열의 구조나 내용이 바뀌어도 결과는 동일하다. 중요한 건 참조의 독자성뿐이다.

JS에는 객체 구조가 같은지 비교할 방법이 없다. JS에서는 같은 것을 참조하는지만 비교할 수 있다.
다만 객체 구조를 비교하는 코드를 만드는 건 생각보다 복잡하므로 조심해야 할 게 많다.
객체의 한 종류인 함수끼리 비교해야 한다고 가정해보자. 두 함수의 참조가 '구조적으로 일치하는지' 어떻게 판단할 수 있을까? 함수 자체를 문자열로 바꿔서 두 문자열을 비교한다고 하더라도 이 방법으로는 클로저등을 고려할 수 없어 제대로 된 비교가 불가능하다. 이런 코너 케이스 전체를 다루는 건 거의 불가능하며 JS에서는 객체 구조를 비교할 방법을 제공하지 않는다.