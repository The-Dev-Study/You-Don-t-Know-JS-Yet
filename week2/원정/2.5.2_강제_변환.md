# 2.5.2 강제 변환
강제 변환은 한 타입의 값이 다른 타입의 값으로 변하는 걸 의미한다. 강제 변환은 JS를 지탱하는 커다란 기둥 중 하나이다.

그런데 개발자 입장에서 강제 변환과 일치 연산자 같은 비교 연산자를 동시에 고려해야 하는 상황을 맞닥뜨리면 혼란이 가중된다.

== 연산자는 === 연산자와 유사한 방식으로 피연산자가 같은지 비교한다. 만약 피연산자가 같은 타입이라면 ==와 ===는 어떠한 차이도 없이 완전히 동일하게 작동한다.

그런데 피연산자의 타입이 다른 경우 == 연산자는 비교 이전에 강제로 타입을 맞추는 작업을 수행한다는 점에서 === 연산자와 차이가 있다. == 연산자는 강제 변환을 먼저 실행해 피연산자의 타입을 맞춘 이후에 === 연산자처럼 작동한다. 필자는 이런 면 때문에 == 연산자를 강제 변환 동등 비교 연산자라고 설명하는 게 적합하다고 생각한다.

예시를 살펴보자

``` js
42 == "42" // true
1 == true // true
```

두 줄 모두 피연산자의 타입이 다르다. == 연산자가 숫자형 피연산자를 선호한다는 본질을 알고있다면 "" == 0이나 0 == false 같은 코너 케이스를 피할 수 있다.

아마도 '그럼 나는 == 말고 === 연산자만 사용해서 타입 강제 변환이 일어나지 않게 할 거야!'라고 생각할지도 모르겠다. 미안하지만 그렇게 쉽게 타입 강제 변환을 피할 수는 없다.

왜냐면 비교 연산자에는 == 말고도 <, >, 심지어 등호가 있는 <=, >=도 있기 때문이다.

==와 마찬가지로 <,> <=, >=는 피연산자들의 타입이 같으면 ===처럼 작동한다. 하지만 타입이 다른 경우에는 타입 강제 변환이 먼저 일어난다.

예시를 살펴보자
``` js
var arr = [ '1', '10', '100', '1000' ];
for (let i = 0; i < arr.length && arr[i] < 500; i++) {
    // 순회는 세 번 일어난다.
}
```

for 문에서 쓰인 비교 코드 i < arr.length에서 i와 arr.length는 항상 숫자이므로 < 연산자는 타입 강제 변환으로부터 안전하다. 하지만 arr[i] < 500에서 arr[i]는 항상 문자열이므로 이때의 < 연산자는 타입 강제 변환을 수반한다. 네 번째 비교에서 거짓이 반환되므로 순회는 세 번까지만 일어나고 이후에는 반환이 멈춘다.

비교 연산자는 피연산자가 모두 문자열인 경우를 제외하고는 숫자 타입으로 타입을 변환해 비교를 진행한다. 피연산자 모두가 문자열인 경우에는 사전처럼 알파벳 순으로 문자열을 비교한다.

비교 연산자를 사용할 때 타입 변환을 피할 방법은 피연산자의 타입을 일치시키는 것 말고는 없다. 하지만 개발을 하다보면 피연산자끼리 타입이 다른 경우를 피하지 못할 가능성이 높다.

그러니 타입 강제 변환을 수반하는 비교에 대해 배우는걸 피하기보다 비교 연산자의 작동 방식을 제대로 배우고 받아들이는 게 더 현명한 접근이다.