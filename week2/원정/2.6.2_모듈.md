# 2.6.2 모듈

모듈 패턴은 클래스와 마찬가지로 논리적 단위 기준으로 데이터와 행동을 그룹화하는 데 그 목적이 있다. 그런데 모듈에는 클래스와 다른 중요한 몇 가지 차이점이 있다. 가장 눈에 띄는 차이점은 문법이다.

## 클래식 모듈
클래식 모듈의 주요 특징은 최소한 한 번 이상 실행되는 외부 함수이다. 이 외부 함수는 모듈 인스턴스 내부의 숨겨진 데이터를 대상으로 작동하는 함수가 있는 '인스턴스'를 반환한다.

이런 클래식 모듈은 단순한 함수이기도 하고 함수를 호출하면 모듈 인스턴스가 생성되기 때문에 클래식 모듈 인스턴스에 있는 함수를 모듈 팩토리라고 설명하기도 한다.

앞서 살펴본 Publication, Book, BlogPost 클래스를 클래식 모듈 형태로 바꿔보며 더 자세히 알아보자

``` js
function Publication(title, author, pubDate) {
    var publicAPI = {
        print() {
            console.log(`
                제목: ${ title }
                저자: ${ author }
                발행일: ${ pubDate }
            `);
        }
    };

    return publicAPI;
}

function Book(bookDetails) {
    var pub = Publication(
        bookDetails.title,
        bookDetails.author,
        bookDetails.publishedOn
    );

    var publicAPI = {
        print() {
            pub.print();
            console.log(`
                출판사: ${ bookDetails.publisher }
                ISBN: ${ bookDetails.ISBN }
            `);
        }
    };

    return publicAPI;
}

function BlogPost(title, author, pubDate, URL) {
    var pub = Publication(title, author, pubDate);

    var publicAPI = {
        print() {
            pub.print();
            console.log(URL);
        }
    };

    return publicAPI
}
```

클래스는 메서드와 데이터를 객체 인스턴스에 저장하며, 메서드와 데이터에 접근하려면 접두사 this.를 사용해야 한다. 반면 모듈에서는 this. 없이도 스코프 내 식별자 역할을 하는 변수를 사용해 메서드와 데이터에 접근할 수 있다.

클래스에서는 인스턴스의 API가 클래스 자체에 정의되어 있고 모든 데이터와 메서드가 공개되어 있다. 반면 모듈 팩토리 함수에서는 외부에 노출된 공개 메서드를 사용해 객체를 명시적으로 만들고 반환한다. 이때 데이터나 참조되지 않은 메서드는 팩토리 함수 내에 비공개로 남는다.

팩토리 함수와 이를 변형한 코드는 2020년대인 지금까지도 광범위하게 사용된다. 

이번에는 모듈 팩토리 함수를 인스턴스화해서 사용하는 예시를 살펴보자

``` js
var YDKJSY = Book({
    title: "You Don't Know JS Yet",
    author: "카일 심슨",
    publishedOn: "2020년 1월",
    publisher: "독립 출판",
    ISBN: "979-86024774429",
});

YDKJSY.print();

var forAgainstLet = BlogPost(
    "For and against let",
    "카일 심슨",
    "2014년 10월 27일",
    "https://...."
);

forAgainstLet.print();
```

클래스와 다른 점은 new 없이 모듈 팩토리를 일반 함수처럼 호출해서 사용한다는 점이다.

## ES 모듈
ESM은 앞서 배운 클래식 모듈과 동일한 취지를 갖는 문법으로 AMD, UMD, CommonJS의 주요 변형과 그 용례를 고려해 만들어졌다. 하지만 구현의 관점에서 상당히 큰 차이가 있다.

첫 번째 차이는 ESM에는 모듈을 정의하는 래핑 함수가 없다는 점이다, ESM은 파일이라는 맥락에서 구현된다. ES 모듈은 항상 파일 기반이다. ES 모듈 파일 하나는 모듈 하나이다.

두 번째는 ES 모듈을 사용할 때 모듈 API와 직접 상호작용하지 않는다는 점이다. 개발자는 export 키워드를 사용해 변수나 메서드를 퍼블릭 API로 정의한다. 모듈 안에 있는 변수나 메서드라도 export 키워드가 붙어 있지 않으면 클래식 모듈에서처럼 숨김 상태가 된다.

세 번째는 ES 모듈을 인스턴스화하지 않아도 import 키워드를 사용해 가져오기만 한다면 단일 인스턴스처럼 사용할 수 있다는 점이다. 프로그램 내에서 import 키워드를 사용해 처음 모듈을 가져온 순간 인스턴스가 생기고, 동일한 모듈을 다른 곳에서 import할 때는 이미 생성된 모듈의 참조만 가져온다.

실제로 실행 가능한 예시에서 여러 인스턴스가 필요하다고 가정하고 이에 맞게 코들르 다음과 같이 작성했다. ES 모듈과 클래식 모듈을 합쳐놓은 형태이다.

``` js
function printDetails(title, author, pubDate) {
    console.log(`
        제목 ${ title },
        저자 ${ author },
        발행일 ${ pubDate }
    `);
}

export function create(title, author, pubDate) {
    var publicAPI = {
        print() {
            printDetails(title, author, pubDate);
        }
    };

    return publicAPI;
}
```

또 다른 ES 모듈 blogpost.js에서 모듈 publication.js를 가져오고 사용해보자.
``` js
import { create as createPub } from "publication.js";

function printDetails(pub, URL) {
    pub.print();
    console.log(URL);
}

export function create(title, author, pubDate, URL) {
    var pub = createPub(title, author, pubDate);

    var publicAPI = {
        print() {
            printDetails(pub, URL);
        }    
    };

    return publicAPI;
}
```

마지막으로 또 다른 ES 모듈인 main.js을 만들고 여기서 blogpost.js 모듈을 불러온다.

``` js
import { create as newBlogPost } from "blogpost.js";

var forAgainstLet = newBlogPost(
    "For and against let",
    "카일 심슨",
    "2014년 10월 27일",
    "https://...",
);

forAgainstLet.print();
```

> import 문에 있는 as newBlogPost는 없어도 무방하다  as newBlogPost가 없다면 모듈 최상위 레벨에서 정의한 함수 create()를 가져온다. 그런데 이 경우라면 create() 함수 이름을 그냥 사용하는 것 보다는 가독성을 위해 이름을 바꾸는 편이 낫다. 

예시에서 살펴본 것처럼 ES 모듈 내부에 클래식 모듈을 함께 사용하면 모듈 인스턴스를 여러 개 만들 수 있다. 이 방법 말고도 팩토리 함수 create() ES 모듈 내부에 클래스를 만들고 이 클래스를 노출하는 방법도 있다. 두 방법 모두 결과는 같지만 이미 ES 모듈을 사용하고 있으므로 클래스보다 클래식 모듈을 사용하는 것을 권장한다.

모듈 인스턴스 하나만 필요하다면 앞서 살펴본 복잡한 예시는 무시하고 export 키워드를 사용해 필요한 메서드를 직접 내보내 사용하면 된다.