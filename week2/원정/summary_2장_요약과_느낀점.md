# 2장 요약과 느낀점

## 파일은 프로그램입니다.
JVM 계열 개발자로서, 파일 단위가 아닌 컴파일된 결과물을 하나의 프로그램으로 인식하는 사고방식에 익숙했다. 그래서 JS에서 각 .js 파일이 독립된 프로그램처럼 취급된다는 개념이 낯설었다. 특히 빌드나 번들링으로 파일이 하나로 합쳐지는 현대 JS 환경과 맞물리면서 "왜 파일이 프로그램이지?"라는 생각이 들었다.

2.6.2와 2.1을 다시 읽고나니 무슨 말인지 이제야 알겠다.
NestJS를 구성하던 수 많은 요소들이 각각의 프로그램이었다니.. 새롭게 알게된 사실이다.

## 값
JS에서 값은 원시 타입과 객체 타입으로 분류된다는 사실을 잘 기억해야겠다. 그리고 null, undefined 이야기 할 만한 주제인 것 같다. 다른 사람들은 어떻게 생각하는지? 나는 JVM 환경에 익숙해져서 관성처럼 null을 쓰곤 했는데 (이럼 안됨) Knex.js(JS Query Builder 라이브러리) 공식 문서보니 주로 undefined를 사용하긴 하더라.

> undefined는 정의되지 않은 값을 뜻 함. 즉, 아직 값이 할당되지 않은 상태. null은 의도적으로 비어 있음을 표시한 값. 개발자가 여기에는 아무 값도 없다라고 명시하는 용도로 사용

그리고, 심벌 쓰는지? 써봤다면 어떨 때 쓰는지 궁금하다.

## 값의 타입
저자가 예제에서
``` js
typeof null; // object <- 버그다
```
버그다라고 표시해놨는데, 찾아보니 진짜 버그가 맞다.

1995년 JS 초기버전에서 값은 내부적으로 타입 태그와 실제 값을 비트 단위로 결합해 저장했는데 null 패턴이 객체와 동일하게 해석되도록 설계되어버린 것

하지만 하위 호환성이 중요하기 때문에 버그를 고치지 못하고 남아있는 것이라고 한다.

## 변수 선언과 사용
var와 let, const가 나온다. var는 함수 스코프, let과 const는 블록 스코프이다. 근데 필자는 var를 아예 쓰지 말자는 것에 반대한다. 뒤에 나올 '== 사용을 막지 말아야 한다' 의견과 동일한데. 필자는 덮어놓고 모른채 하기 보다는 교육을 통해 모두가 그 위험성을 알고 제대로 사용하기를 원하는 스타일에 가까운거 같긴하다. 뭐 이건 취향차이니깐... 난 필자 의견에 찬성이긴 하다.
'const를 통해 객체를 정의하지 말라'고도 조언한다. const로 객체를 선언하더라도 값은 변경할 수 있기 때문에 혼란을 불러일으키기 때문이라고 한다.

## 비교
== 와 === 이야기를 한다. 이름이 헷갈리니 둘의 이름을 잘 알아두자 '느슨한 비교', '엄격한 비교'라고도 하고 '느슨한 동등 연산자', '엄격 동등 연산자'라고도 한다. 느슨이와 엄격이.. 내 수준에선 이 정도가 맞다.. 헷갈린다.

먼저 === 이야기를 하는데 ===가 비교를 잘 해줄 것이라는 개발자들의 많은 믿음과는 다르게 거짓말을 꽤나 잘한다는 사실을 말해준다. 원시 타입에서는 NaN, -0 문제가, 객체 타입에서는 객체끼리의 비교가 불가능한 문제가 있다.

객체끼리의 비교는 좀 특이한데 여기서는 '독자성 일치'라는 여려운 용어를 쓴다. 객체 내부 구조가 어떻던 관계 없이 참조가 같으면 true 반환한다는 소리다. 어렵게 받아들이지 말자.

객체 구조 같은지 비교할 방법이 없다고 한다. "아닌데 많은데?"라면서 책 읽었는데 생각지도 못한 함수 예를 들더라 함수는 그렇겠다 싶었다.. (함수가 아닌 경우에는 Object.Keys()로 두 객체의 프로퍼티가 같은지 확인하는 방식을 통해 두 객체가 동일한지 확인하는 방법을 썼던 기억이 있다.)

## 강제 변환
이제 ==를 다룬다 필자는 아예 이름을 '느슨한 동등 연산자'에서 '강제 변환 동등 비교 연산자'로 바꾸는건 어떤지 제안한다. 동의한다. 매커니즘을 보면 더욱 그렇다는 생각이 들었다.

## 모듈
ESM이 아닌 CommonJS에서도 export 문법은 굉장히 많이 활용되지 않나? 여전히 혼동되는 부분이다. nestJS의 예제 코드중 일부이다.

``` ts
import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Controller('cats')
export class CatsController {
  @Post()
  create(@Res() res: Response) {
    res.status(HttpStatus.CREATED).send();
  }

  @Get()
  findAll(@Res() res: Response) {
     res.status(HttpStatus.OK).json([]);
  }
}

```
이 문법은 ESM이지만, 실제로는 CommonJS로 변환된다. (tsconfig에 따라 다르지만 일반적으로는 CommonJS로 변환된다.)

내 질문을 다시 정리해보자 'ESM이 아닌 CommonJS에서도 export과 같은 ESM 문법이 혼용되는가?'이다 정답은 '아니다' TS는 ESM 스타일이기 때문에 import, export와 같은 키워드가 사용된 것 뿐이다.

TypeScript는 ESM 스타일을 권장하며, 대부분의 프레임워크에서도 이를 따르고 있다. 다만 빌드 과정에서 실제 결과물을 CommonJS 형태로 변환되기 때문에 혼동이 생긴다.

나는 TypeScript에서 사용하는 이 방식을 완전한 ESM이라기보다 ESM 스타일이라고 부르는 것이 더 적절하다고 생각한다. tsconfig.json 설정을 바꿔 빌드 결과를 ESM으로 변경할 수도 있지만, 그 경우 코드 역시 수정해야 한다. 예를 들어 모든 import 문을 상대 경로 (./)로 바꾸고, 파일 확장자를 .js 명시해야 한다.
즉, TypeScript는 문법적으로는 ESM을 따르지만, 완전히 ESM과 호환된다고 보기는 어렵다.

## 더 깊은 토끼 굴로
이 책은 시간 두고 두 세 번 읽었을 때 재밌는 거 같다.