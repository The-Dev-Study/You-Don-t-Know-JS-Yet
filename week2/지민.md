# Chap 2. 자바스크립트 조망하기
## 2.1. 파일은 프로그램입니다.
보통 많은 웹 사이트나 애플리케이션은 수많은 js 파일로 이루어져있음  
-> 그렇기 때문에 하나의 프로그램이라고 생각하기 쉽지만 `JS에서는 파일 가각이 별도의 프로그램`

💡 why? 오류 처리를 보셈  
JS는 파일을 프로그램으로 취급하기 때문에 파일 하나에만 오류가 있어도 파싱/컴파일/실행 단계에서 파일이 처리되지 않을 수 있음 
```
핵심 원칙: JS에서는 파일 하나하나가 별도의 프로그램으로 취급

이유 (오류 처리): 만약 파일 A, B, C가 있을 때, 파일 B에만 오류가 있다면 JS 엔진은 파일 B를 처리(파싱/컴파일/실행)하는 것을 멈출 수 있음
이는 JS가 파일을 전체 프로그램의 일부가 아닌, 독립적인 프로그램으로 간주하기 때문

비유: 하나의 거대한 책이 아니라, 여러 권의 독립된 얇은 소책자로 이루어진 도서관이라고 생각 -> 소책자 중 하나(파일)에 문제가 있어도, 다른 소책자들은 독립적으로 존재
```
(Note. 상당수의 웹 플젝은 빌드 도구를 써서 분리된 파일 하나로 합쳐 배포함 ➡️ 이 경우 단일 파일을 전페 프로그램으로 취급)


💡 각 파일이 독립적이라면 어떻게 협력해서 하나의 큰 애플리케이션 만들 수 있을까?  
1. 전역 스코프 사용
독립적인 js 파일 여러개를 하나의 프로그램으로 작동시키기 위해선 `전역 스코프`를 사용해 파일 간 상태 공유, 공통으로 사용하는 기능 접근할 수 있게 만드는 방법 뿐  
이렇게 전역 스코프 네임페이스에서 여러 파일이 조합되면 런타임에서는 하나의 애플리케이션으로 작동  

2. 모듈을 통한 협력
모듈도 파일 기반  
> 모듈: 상태와 외부에 노출할 용도로 만든 상태 조작 메서드의 모음  

파일을 import문이나 <script type=module> 태그를 통해 읽는 경우 해당 파일은 하나의 모듈로서 처리   
➡️ JS는 각 모듈을 별도로 처리  
하지만 한 모듈이 다른 모듈을 불러오면 (import/export), 런타임에서 이 두 모듈이 상호작용하며 하나의 애플리케이션을 구성  
(런타임에 독립된 js 파일 여러개를 전역 스코프에서 조합해 처리하는 것처럼 한 모듈에서 다른 모듈을 불러오면 런타임에서 두 모듈이 상호작용할 수 있음)

**🚩 단일 파일이든 모듈이든, 어떤 코드 구성 패턴과 로딩 메커니즘을 사용하든 상관없이 파일 하나를 제 3의 작고 독립적인 프로그램(파일)과 협력해 프로그램 전체를 작동시키는 고유한 작은 프로그램이라고 생각해야 된다.**

<br/>

## 2.2 값
프로그램에서 정보의 가장 기본적인 단위는 값이고 값에 데이터가 저장됨  

JS에서 값은 크게 두 타입으로 분류
- 원시 타입 (Primitive Type): 불변(Immutable)하고 단순한 데이터
- 객체 타입 (Object Type): 여러 속성(Property)을 가질 수 있는 복합적인 데이터

JS에선 리터럴(literal)을 사용해 프로그램에 값을 주입함 
> 리터럴은 프로그램을 만들 때 소스 코드 내에 값을 직접 표현하는 방식을 뜻함
예) greeting('제 이름은 카일입니다.');  

1. 문자열 리터럴
문자열 범위를 정할 떄는 큰따옴표, 작은따옴표, 백틱 사용 가능 그러나 작동 방식에 차이가 있음
```
const firstName = '카일';

console.log("제 이름은 ${ firstName }입니다.");
// 제 이름은 ${ firstName }입니다.
console.log('제 이름은 ${ firstName }입니다.');
// 제 이름은 ${ firstName }입니다.
console.log(`제 이름은 ${ firstName }입니다.`);
// 제 이름은 카일입니다.
```
예시를 보면 백틱으로 감싼 문자열만 문자열 내 변수 표현식에 현재값인 카일로 대체된걸 볼 수 있음  ➡️ 🧑‍🏫 이런 방식을 `보간법`이라고 함  
보간법 필요 ㄴㄴ ➡️ 걍 따옴표 쓰자  
보간법 필요 ㅇㅇ ➡️ 백틱 ㄲ  

2. 문자열 말고 불리언이나 숫자 같은 원시 리털럴 값을 사용할 수 있음 
  - 불리언: true, false
  - 숫자: 10, 3.14 등. 아주 큰 정수를 다룰 때는 특별한 원시 타입인 **bigint**를 사용
3. 이외에도 null, undefined 원시 타입 지원 두 타입 모두 값의 비어있음 혹은 존재하지 않음을 나타내는데 사용  
  - null: 값이 의도적으로 비어있음을 나타낼 때 사용(값이 없다는 것을 개발자가 명시적으로 설정)
  - undefined: 값이 정의되지 않았거나 (변수 선언만 하고 값을 할당하지 않은 경우), 비어있는 단일 값을 나타낼 때 사용  
글자가 짧다고 null ㄲ 하지말고 비어있는 단일 값을 나타낼 때는 undefined 사용하자
4. 심벌: 사람이 추측할 수 없게 만든 특수한 숨김값으로 객체에서 특정한 키를 만들 떄 주로 사용
   예) ``` hitchhikersQuide[ Symbol("삶의 의미")]; // 42```
   ➡️ 여기서 Symbol("삶의 의미")는 hitchhikersQuide 객체에 접근하기 위한 고유한 키  
   심벌은 일반적으로 직접 사용하진 않고 대게 라이브러리나 프레임워크 같이 좀 더 저차원의 코드에서 사용함

### 2.2.1 배열과 객체
1. 배열
: 특수 유형의 객체로 객체 내 정렬된 데이터에는 숫자 인덱스가 매겨짐(0부터 시작)
배열에는 원시타입, 객체타입 상관없이 모든 타입의 값이 들어갈 수 있음(함수와 같은 객체도 가능하다는 뜻)

3. 객체
: 배열보다 좀 더 일반적인 데이터 타입으로, 정렬되지 않은 키-값 쌍을 모아놓은 컬렉션  
(키-값 쌍 (Key-Value Pairs): 객체는 키(Key)와 그 키에 연결된 값(Value)이 한 쌍을 이루는 형태로 데이터를 저장)  
배열이 인덱스를 통해 요소에 접근한다면 객체는 키(또는 프로퍼티)를 사용해 요소에 접근  
예) me.first, me['first'] 동일한 결과값

### 2.2.2 값의 타입
```
typeof 42; // "number" 
typeof "abc"; // "string" 
typeof true; // "boolean" 
typeof undefined; // "undefined" 
typeof null; // "object" ← 이런, 버그입니다!
typeof { "a": 1 }; // "object" 
typeof [1, 2, 3]; // "object" 
typeof function hello(){}; // "function"
``` 
💡 null은 왜 null이 아닌 object를 반환할까? 배열도 왜 array가 아닌 object를 반환할까?  
문자열을 숫자로 바꾸는 것처럼 값의 타입을 변경하는 것을 `강제 타입 반환(coercion)`이라고 함 그것떄문임  

<br/>

## 2.3 변수 선언과 사용
JS에서 값은 리터럴 값으로 표현하거나 변수에 담긴 채로 다룸 ➡️ 변수는 값을 담는 상자!

변수를 사용하기 위해선 변수 선언(생성)이 선행되어야 함  

식별자(identifier)  
1. var | 변수 선언: 재선언, 재할당 모두 가능. 함수 스코프
2. let | 변수 선언: 재할당 가능하지만, 재선언은 불가능. 블록 스코프
3. const | 상수 선언: 재선언, 재할당 모두 불가능 (반드시 선언 시 값을 할당해야 함). 블록 스코프를 가지며, 값이 변하지 않는 곳에 사용

const는 변수의 재할당만 막을 뿐, 변수가 가리키는 객체 내부의 값을 바꾸는 것까지 막지는 못함. 이런 관점에서 const를 사용해 객체를 정의하는 것은 좋지 않음  
 ➡️ 객체를 재할당하는 것은 불가하지만 값은 바꿀 수 있기 때문  
 
 즉, const는 변수에 새로운 값을 대입하는 행위(재할당)만 금지   
 ➡️ 여기서 '값'이란 변수가 실제 데이터를 담고 있거나, **데이터가 저장된 메모리 주소(참조)**를 가리키고 있는 것을 의미

```
const myAge = 30; // 원시 타입 (30이라는 실제 값을 가짐)
// myAge = 31; // ❌ 에러: 재할당 불가! (값을 바꿀 수 없음)

const myObject = { name: "Kyle" }; // 객체 타입 (객체의 메모리 주소를 가리킴)
// myObject = { name: "John" }; // ❌ 에러: 재할당 불가! (주소를 바꿀 수 없음)
```
객체(Object, Array)는 원시 타입과 달리, 변수에 실제 데이터가 저장되는 게 아니라 **데이터가 저장된 메모리 주소(참조)**만 저장  
`const myObject = { name: "Kyle" };`라고 선언하면, myObject 변수는 `{ name: "Kyle" }` 객체가 저장된 메모리 공간을 가리키고 있는 것  
- 재할당 불가: const 덕분에 myObject는 다른 객체의 주소를 가리키도록 변경될 수 없음 (예: myObject = { ... }는 금지)
- 값 변경 가능: 하지만 myObject가 가리키는 메모리 공간 안의 내용물을 변경하는 것은 const와 아무 상관이 없이 가능

🤔 불변성 오해 유발 떔에 쓰지 말라는 거?

var, let, const 말고 특정 스코프 내에 변수와 같은 식별자를 선언하는 다른 방법
1. 함수 매개변수
```
function hello(myName) { 
  console.log(`${ myName } 님, 안녕하세요.`);
}
hello("카일"); // 카일 님, 안녕하세요.
```
hello의 유효범위는 가장 바깥 스코프이고 함수를 참조함. 반면 함수의 매개변수 myName은 함수 안에서 생성되므로 함수 스코프에서만 접근 가능(함수의 가장 안쪽 스코프에 묶임)  
hello, myName은 var로 선언한 변수처럼 작동

2. catch절 만들 때 오류 식별자
```
try {
  someError();
} catch (err) {
  console.log(err);
```
이때 err는 let으로 선언한 변수처럼 블록 스코프임   

<br/>

## 2.4 함수
JS로 개발할 때 프로시저(procedure)룰 프로그램에 녹여내기 위해 심사숙고하며 함수를 작성해야 함 
> 프로시저: 한 번 이상 호출할 수 있고 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음

1. 함수 선언문  
```
function awesomeFunction(coolThings) {
  // ...
  return amazingStufff;
```
험수 선언으로 정의한 함수는 식별자(함수 이름)awesomeFunction과 실제 함수를 나타내는 값의 연관이 코드 실행단계가 아닌 컴파일 단계에서 맺어짐   
➡️ 코드 실행 전에 이미 함수가 정의되어 메모리에 올라가기 때문에, 함수 선언문이 코드의 아래쪽에 있어도 위에서 호출할 수 있음  

2. 함수 표현식
```
let awesomeFunction = ...
const awesomeFunction = ...
var awesomeFunction = function(coolThings) {
  // ...
  return amazingStuff;
};
```
함수를 값으로 취급하여 let, const, var 같은 변수에 할당하는 방식
이렇게 함수 표현식으로 선언한 함수는 함수와 함수 식별자 코드가 실행되기 전까지는 관계를 맺지 않음  
➡️ 변수처럼 동작하기 때문에, 해당 줄의 코드가 실행되기 전에는 호출할 수 없어

JS에서 함수는 할당 가능하고 어디든 전달 가능한 값이라는 특징은 매우 중요함(JS에서 함수는 객체의 한 종류)  
- 함수는 오로지 하나의 값만 반환할 수 있음 🌝 여러 개 반환하고 싶으면 객체나 배열로 감싸 반환하기   

- 함수는 값이므로 함수를 객체의 프로퍼티로 할당 가능
```
var whatToSay = {
  greeting() {
    console.log("안녕하세요!");
  },
  question() {
    console.log("이름이 뭔가요?");
  },
  answer() {
    console.log("제 이름은 카일입니다.");
  }
};
whatToSay.greeting();
// 안녕하세요!
```
<br/>

## 2.5 비교
### 2.5.1 같음에 대한 고찰
`같다`란 정확히 어떤 의미일까?
- 일치 비교(===)
- 동등 비교(==)

```
3 === 3.0; // true
"yes" === "yes"; // true
null === null; // true
false === false; // true

42 === "42"; // false
"hello" === "Hello"; // false
true === 1; // false
0 === null; // false
"" === null; // false
null === undefined; // false
```

1. 일치 연산자가 특수한 값인 NaN이나 -0을 만날 때
```
NaN === NaN // false
0 === -0 // true
```
일치 연산자: 🤔💭 나 정말 으심되.  
그래서 일치연산자는 NaN, -0이랑 같이 사용하지 않는 게 좋음  `Number.isNaN()`, `object.is()` 사용하자   

2. 객체끼리 비교할 때
```
[1,2,3] === [1,2,3]; // false
{a:42} === {a:42}; // false
(x => x*2) === (x => x*2); // false
```
일치 비교는 값의 본질이나 내용을 비교함 따라서 원시타입에선 42 === 42 실제 숫자인 42끼리 비교   
객체끼리 비교할 때는 **내용(구조적 일치)**을 비교하는 게 아니라, 두 변수가 메모리 상의 같은 객체를 가리키고 있는지(동일한 참조)를 비교 ➡️ 참조 독자성(Reference Identity) 비교

JS에서 객체는 참조에 의해 고정되며 참조 복사본을 사용해 할당, 전달됨 그리고 참조를 대상으로 일치 비교가 발생함
```
var x = [ 1, 2, 3 ]; // x는 메모리 A에 있는 배열을 참조함
var y = x;           // y도 메모리 A에 있는 *같은* 배열을 참조함

y === x; // true (두 변수 모두 메모리 A라는 '같은' 대상을 가리키므로)

y === [ 1, 2, 3 ]; // false (오른쪽은 메모리 B에 새로 생성된 배열을 참조함)
x === [ 1, 2, 3 ]; // false (x가 가리키는 A와 새로 만들어진 B는 다른 객체이므로)
```
`참조 독자성`
js에선 객체 구조가 같은지 비교할 방법이 없음 객체 구조가 같은지 비교하려면 직접 코드 짜야댐  


### 2.5.2 강제 변환
