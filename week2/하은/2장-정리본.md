# [2장] 조망하기

## 2.1 파일은 각각 별도의 고유한 작은 프로그램이다.

자바스크립트에서 각 독립적인 파일(`.js` 파일)은 개별 프로그램이다. 웹 애플리케이션 전체를 하나의 프로그램으로 생각하기 쉽지만, `JS`는 그렇게 작동하지 않는다고 함!

독립적인 `.js`파일들은 **전역 스코프**를 통해 파일 간 상태를 공유하고, 공통으로 사용하는 기능에 접근함으로써 하나의 프로그램으로 작동된다. -> 런타임에는 하나의 애플리케이션으로 작동하게 됨!

**전역 스코프**

-   코드 어디서든 접근 가능한 변수 및 함수가 정의되는 범위.
-   `var`는 window(브라우저)나 global(Node.js)에 등록되지만, `let`과 `const`는 선언된 블록 스코프에 등록된다.
-

### 각 파일을 별도의 프로그램으로 봐야하는 이유

#### 독립형 JS에서의 오류 처리 방식

```js
// file1.js
console.log('file1 실행');
var sharedData = '공유 데이터';

// file2.js - 런타임 오류
console.log('file2 시작');
throw new Error('런타임 에러!');
console.log('file2 끝');

// file3.js
console.log('file3 실행');
```

**결과:**

```
✅ "file1 실행"
✅ "file2 시작"
❌ Uncaught Error: 런타임 에러!
⚫ file3.js는 로드되지만 실행 안 됨
```

-   파일 하나에만 오류가 있어도 (파싱/컴파일 또는 실행 단계에서) 다음 파일의 처리되지 않을 수 있다.
-   각 파일을 순차적으로 다운로드/파싱/실행함 -> 이 과정에서 중간에 어떤 파일에서 오류가 발생해 실패하면 멈추고 이후 파일은 시도도 하지 않음

#### ES6 모듈 방식에서의 오류 처리 방식

```js
// file1.js
console.log("file1 모듈 실행");
export const sharedData = "공유 데이터";

// file2.js - 문법 오류
function broken( {  // ❌ SyntaxError
  console.log("broken");
}

// file3.js
console.log("file3 모듈 실행");
import { sharedData } from './file1.js';
console.log(sharedData);
```

**결과:**

```
✅ "file1 모듈 실행"
❌ Uncaught SyntaxError in file2.js
✅ "file3 모듈 실행"  ← 🎉 여전히 실행됨!
✅ "공유 데이터"
```

**브라우저 동작:**

```
1. file1.js 다운로드 → 파싱 ✅ → 실행 ✅
2. file2.js 다운로드 → 파싱 ❌ → file2만 실패
3. file3.js 다운로드 → 파싱 ✅ → 실행 ✅ ← 계속 진행!
```

> 별도의 프로그램인데 오류가 있으면 다음 파일이 처리되지 않는다는 부분이 좀 헷갈렸음... 별도 프로그램이면 에러가 있어도 다 실행이 돼야 할 것 처럼 느껴짐
> `Es Modules`을 사용하면 에러가 발생한 모듈과의 의존성이 없다면,

<!-- 상황전통적 스크립트ES6 모듈file2 문법 오류file3 로드 안 됨 ❌file3 정상 실행 ✅file2 런타임 오류file3 실행 안 됨 ❌file3 정상 실행 ✅전역 스코프공유 (var, 함수 등)독립 (export만 공유)로드 방식순차적 블로킹병렬 다운로드실행 순서순차 보장비동기적 -->

## 2.2 값

**값**이란?

-   값은 프로그램에서 정보의 기본적인 단위
-   데이터가 저장된다.

**값의 종류**

-   원시 타입
-   객체 타입

### 원시 타입

#### 문자열

-   문자열의 범위를 정할 때는 `"`, `'`, `\``을 사용할 수 있다.
-   백틱은 보간 표현식을 문자열 내부에 삽입하기 위해 추가되었기 때문에 문자열 내부에 변수 표현식이 있는 경우 사용한다.

### 객체 타입

-   배열, 객체, 함수 모두 객체 타입임 `typeof`를 통해 확인가능

## 2.3

변수는 식별자라고도 부르며, 선언 문법에 따라 작동 방식이 다르다.

```js
var myName = '카일';
```

-   접근 범위가 **함수 스코프**이다.

```js
let myName = '카일';
```

-   접근 범위가 **블록 스코프**이다.

> const 타입에 객체 저장하는건 안티 패턴인가?

```js
function hello(myName) {
    console.log(`${myName} 님, 안녕하세요.`);
}

// 위 코드는 현재 코드와 같다고 생각하면 됨
function hello() {
    var myName = arguments[0]; // 매개변수는 var처럼 작동함
    console.log(`${myName} 님, 안녕하세요.`);
}
```

## 2.4 함수

### 함수 선언 방법

#### 함수 선언문

```js
function fn1() {
    return;
}
```

-   함수 선언으로 정의한 함수에서는 식별자(함수의 이름)과 실제 함수를 나타내는 값의 연관이 **컴파일 단계**에서 맺어진다.

#### 함수 표현식

```js
var fn2 = function () {
    return;
};
```

-   함수를 변수 `fn2`에 할당했다.
-   이 경우 함수와 함수 식별자 코드가 **런타임**에 맺어진다.

### 함수의 특징

#### (1) 함수는 값이다

JS에서는 함수형 패러다임을 지원하기 때문에 **함수를 값으로 취급**한다는 걸 생각하자!

> 즉 함수는 할당 가능하며, 어디든 전달이 가능한 값이다!

## 2.5 비교

JS에서의 같음은 '정확하게 일치', '아주 유사', '교환가능'이 될 수 있다. 이를 잘 구분하기 위해 **일치 비교**와 **동등 비교**의 차이를 알아야 한다.

> 일치/동등 연산에서는 타입의 변환이 일어나지 않지만, 다른 비교 연산에서는 **타입 강제 변환을 허용**한다.

### 일치 연산자(===)사용하기

#### 원시 타입 간 비교에서 주의할 점

예상과 다르게 작동하는 두 가지 코드이다.

```js
NaN === NaN; // false
0 === -0; // true
```

-   `NaN`과 `-0`은 되도록 `===`연산자와 같이 쓰지 말자.
-   `NaN`과 비교할 때에는 `Number.isNaN()`을 사용한다.
-   `-0`과 비교할 때에는 `Object.is()`를 사용한다.

### 객체 타입 간 비교에서 주의할 점

> 비교 대상이 객체인 경우 값의 본질 또는 내용이 아닌 **구조적 일치**를 비교하게 된다. JS에서는 객체끼리 비교할 때 비교 연산자가 구조적 일치를 판단하지 않는다. 대신 참조 일치를 비교한다 -> 도대체 이게 뭔말임 진짜

```js
[1, 2, 3] = [1, 2, 3];          // false
{ a : 42 } = { a : 42 };        // false
(x => x + 2) === (x => x = 2);  // false
```

### 강제 변환

`==`은 **강제 변환 동등 비교 연산자** 이다. 먼저 변환을 실행하여 피연사자들 간의 타입을 맞춘 후에 `===`처럼 작동한다. `<`, `>`, `<=`,`>=` 모두 타입이 다르면 타입 강제 변환이 먼저 일어나고, 이 때 **대게 숫자형으로 변환**된다.

## 2.6 코드 구조화 패턴

JS에서 코드를 구조화 하는 패턴은 크게 **클래스**와 **모듈**이 있다.

### 2.6.1 클래스

클래스의 동작은 메서드만 가지고 사용할 수 없고, 인스턴스를 통해서 호출할 수 있다.

#### 상속

-   자식 클래스의 인스턴스는 부모 클래스로부터 상속받아 새롭게 재정의한 메서드들을 호출할 수 있다.
    -   상속받은 메서드와 새롭게 정의한 메서드의 이름이 동일한데 공존할 수 있는 걸 **다형성**이라고 한다.

### 2.6.2 모듈

모듈도 그룹화하는게 목적임. 클래스가 상속을 통해 부모와 자식 간 협력했던 것처럼 모듈도 다른 모듈과 협력할 수 있다.

#### 클래식 모듈

클래식 모듈은 최소한 한 번 이상 실행되는 외부 함수이다.

-   모듈 인스턴스의 숨겨진 데이터를 사용하는 함수를 포함하는 **인스턴스**를 반환함

```js
const classicModule = Publication(title, author, pubDate){
    var publicAPI = {
        print(){
            console.log(`
                제목: ${title}
                저자: ${author}
                발행일: ${pubDate}
            `)
        }
    }
}

classicModule.print(); //  이를 모듈 팩토리라고 함
```

모듈 팩토리 함수에서는 외부에 노출된 공개 메서드 `Publication`을 통해 객체를 명시적으로 만들고 반환한다.

이 때 반환된 객체에서 참조하지 않는 메서드와 데이터는 비공개로 남게 된다.

> 클래스와 다른 점은 `new` 없이 모듈 팩토리를 일반 함수처럼 호출해서 사용한다는 것이다.

#### ES 모듈

ES 모듈은 ES6에서 도입되었고 클래식 모듈과 동일한 취지를 갖는 문법이다.

그러나 구현 관점에서는 큰 차이가 존재함.

##### 차이점

**(1) ES 모듈은 **래핑 함수**가 없다.**

ES 모듈은 파일이라는 맥락에서 구현된다.

**(2) 모듈 API와 직접 상호작용하지 않는다.**

`export` 키워드가 붙은 퍼블릭 API가 아니라면 모듈 내부의 변수나 메서드는 모두 비공개가 된다.

**(3) ES 모듈을 인스턴스화하지 않아도 `import`키워드로 갖고와 단일 인스턴스처럼 사용할 수 있다.**

-   `import` 키워드로 처음 모듈을 갖고 올 때 인스턴스가 생긴다.
-   그 이후에 동일한 모듈을 다른 곳에서 `import`하면 **이미 생성된 모듈의 참조만 갖고 오게 된다.**

> ES 모듈은 싱글턴 패턴을 따른다고 할 수 있다.

인스턴스가 여러 개 필요한 경우, `ES 모듈`을 클래식 모듈 스타일의 `팩토리 함수`로 작성하면 된다.

```js
function printDetails(title, author, pubDate) {
    console.log(`
        제목: ${title}
        저자: ${author}
        발행일: ${pubDate}
    `);
}

// ES 모듈을 팩토리 함수 형태로 작성한 것
export function create(title, author, pubDate) {
    var publicAPI = {
        print() {
            printDetails(title, author, pubDate);
        },
    };

    return publicAPI;
}
```
