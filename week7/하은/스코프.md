# 스코프

> -   주어진 구문에서 접근 가능한 변수를 JS 엔진이 어떻게 결정하는가.
> -   이름이 같은 두 변수가 있는 경우 JS 엔진이 이를 어떻게 처리하는가.

## 1.2 컴파일 vs 인터프리트

-   **컴파일레이션**: 텍스트 형식으로 작성한 코드를 처리하여 컴퓨터가 이해할 수 있는 작업 지시 목록으로 바꾸는 일련의 과정
    -   프로그램을 한 번에 처리한다.
-   **인터프리테이션**: 개발자가 작성한 프로그램을 기계가 해석할 수 있는 명령으로 변환하는 과정
    -   소스코드를 한 줄씩 변환한다.

## 1.3 코드 컴파일

> 스코프는 대게 **컴파일 중에 결정**된다 => 스코프를 이해하기 위해 컴파일레이션과 실행의 관계를 이해해야함

### 코드 컴파일 과정

1. **토크나이징/렉싱** : 문자열을 토큰으로 쪼갠다
    - `var a = 2;` => `var`, `a`, `=`, `2`, `;`
    - 공백은 해당 프로그래밍 언어에서 의미가 있다면 토큰이 됨
2. **파싱** : 토큰 배열을 AST로 변환한다.
3. **코드 생성**: AST를 컴퓨터가 실행 가능한 코드로 변환한다.

### 필수 두 단계

JS가 프로그램을 처리할 때 **파싱**과 **컴파일** 단계를 반드시 거친다. 그 이후에 실행이 된다.

### JS 프로그램이 실행 전 파싱된다는 근거

#### 구문 오류

```js
var greeting = "안녕하세요.";
console.log(greeting);

greeting = ."안녕";
// SyntaxError
```

-   첫 번째 console도 찍히지 않음

#### 초기 오류

엄격모드에서 프로그램을 실행할 때 가이드를 어기는 경우 발생하는 오류이다.

#### 호이스팅

```js
var greeting = '안녕하세요.';
{
    // [보이지 않는 구간] 여기서부터 TDZ(사각지대) 시작!
    // 엔진: "greeting은 이 블록에 있지만, 아직 초기화 안 했어. 건드리지 마."

    greeting = '잘 지내시죠?'; // 🚨 에러 발생! (ReferenceError)
    // 이유: 사각지대(TDZ)에 있는 greeting에 값을 넣으려고 했기 때문입니다.
    // 바깥의 "안녕하세요"를 쓰려는 게 아니라, 아직 안 만들어진 안쪽의 greeting을 건드린 셈이 됩니다.

    let greeting = '안녕!'; // ✅ 여기서부터 TDZ 끝! 이제 사용 가능.
    console.log(greeting);
}
```

## 1.4 컴파일러체

선언을 제외한 모든 변수와 식별자는 할당의 **타깃**혹은 값의 **소스**중 하나임. (`=`)의 좌측과 우측

### JS 엔진이 변수에 역할을 부여하는 방법

#### 1.4.1 할당의 타깃이 되는 경우

```js
students = [ ... ];

nextStudent = getStudentName(73);

for(let student of students) {}

getStudentName(73); // 매개변수에 할당

function getStudentName(studentID){}
```

#### 1.4.2 값의 소스가 되는 경우

값을 사용하는 부분. 함수 호출 부분

## 1.5 런타임에 스코프 변경하기

`eval`과 `with`를 사용하면 런타임에 스코프 수정이 가능하다고 함

## 1.6 렉시컬 스코프

-   **렉시컬 스코프**: 컴파일 타임에 결정되는 스코프
