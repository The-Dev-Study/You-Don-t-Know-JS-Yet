# 3.1.2 이터러블
이터레이터 소비 프로토콜은 이터러블을 사용해 이터레이터 인스턴스를 생성하고, 생성한 이터레이터 인스턴스를 소비해 연산을 마무리한다.인스턴스를 여러 개 만들기만 하면 라나의 이터러블을 여러 번 소비할 수 있다.

JS에서는 어떤 게 이터러블일까? ES6에서는 문자열, 배열, 맵, 셋 같이 기본이 되는 자료구조나 컬렉션을 이터러블로 정의한다.

배열은 이터러블이다. 따라서 다음 예시처럼 전개 구문으로 ... 이터레이터를 소비해 배열을 얕게 복사 할 수 있다.
``` js
var arrCopy = [ ...arr ];
```
문자열 역시 이터러블이므로 전개 구문으로 글자 하나하나를 순회할 수 있다.

이번에는 객체를 포함한 모든 자료형을 키로 허용하는 키-값 형태의 자료구조인 Map(맵)에 대해 알아보자. 맵은 지금까지 살펴본 이터레이터와는 다르게 기본 이터레이터를 지원한다. Map의 내장 메서드 entries를 호출하면 맵의 값뿐만 아니라 키까지 포함한 2차원 배열인 entry 튜플을 순회할 수 있다.

``` js
// DOM 요소 btn1과 btn2가 있다고 가정한다.

var buttonNames = new Map();
buttonNames.set(btn1, "버튼 1");
buttonNames.set(btn2, "버튼 2");

for (let [btn, btnName] of buttonNames) {
    btn.addEventListener("click", function onClick() {
        console.log(`${ btnName }을/를 클릭했습니다.`);
    })
}
```
for ..of 반복문은 맵이 지원하는 기본 이터레이터를 순회하며 [btn, btnName] 문법 (배열 구조 분해)를 사용해 튜플을 키, 값으로 분해한다. 그 결과 첫 번째 반복문이 돌 때는 btn에 btn1이, btnName에는 "버튼 1"이 할당되고, 두 번째 반복문이 돌 때는 btn에 btn가, btnName에는 "버튼 2"가 할당된다.

JS 내장 이터러블은 우리 직관에 부합하는 방식으로 이터레이션을 지원한다. 그런데 가끔은 더 정교한 이터레이션이 필요할 때가 있는데, 이 역시 JS에서도 지원한다.
앞선 예시의 buttonNames에서 값만 추출하고 싶다고 가정해보자 이때 values()를 사용하면 값을 대상으로만 이터레이터가 작동한다.

``` js
for (let btnName of buttonNames.values()) {
    console.log(btnName);
}

// 버튼 1
// 버튼 2
```

배열의 인덱스와 값을 대상으로 순회하고 싶다면 다음과 같이 entries() 메서드를 사용할 수도 있다.

``` js
var arr = [ 10, 20, 30 ];

for (let [idx, val] of arr.entries()) {
    console.log(`[${ idx }]: ${ val }`);
}

// [0]: 10
// [1]: 20
// [2]: 30
```

이렇게 JS의 내장 이터러블은 키만 대상으로 keys() 값만 대상으로 values() 키와 값을 대상으로 entries() 순회하는 메서드를 제공한다.

기본 이터러블을 사용하는 것 외에도 이터레이션 프로토콜을 준수하는 자료구조를 직접 만든다면, 해당 자료구조에 ...과 for ...of 반복문을 적용할 수 있다. 

> 예리한 사람이라면 미묘한 변화가 있었다는 것을 눈치챘을 수 있다. 초반에는 이터레이터 소비에 대해 이야기하다가 주제를 바꿔 이터러블을 순회하는 방법에 대해 이야기 했다. 이터레이션 소비 프로토콜은 이터러블을 대상으로 작동한다. 앞선 예시에서 이터레이션 프로토콜에 직접 이터레이터를 제공할 수 있었던 이유는 이터레이터는 그 자체로 이터러블이기 떄문이다. 기존에 존재하는 이터레이터를 사용해 이터레이터 인스턴스를 만들면 이터레이터 그 자체가 반환된다.