# 3.3 this 키워드
JS를 지탱하는 가장 강력한 메커니즘인 this 키워드는 가장 오해를 많이 받는 메커니즘이기도 하다. 함수에서 this가 가리키는 것이 함수 자기 자신이라는 오해는 만힝 알려진 오해이다. this는 메서드가 속한 인스턴스를 참조한다는 오해도 있다.

앞서 스코프는 정적이며 함수를 정의하는 순간, 해당 스코프에서 사용할 수 있는 한정된 변수 집합을 포함한다. 반변 함수의 실행 컨텍스트는 동적이다. 실행 컨텍스트는 함수를 정의한 위치나 함수를 호출하는 위치와 상관없이 함수의 호출 방식에 따라 결정된다.

즉, this는 함수의 정의에 종속되어 결정되는 변치 않는 특성이 아니라, 함수를 호출할 때마다 결정되는 동적인 특성이다.

실행 컨텍스트는 함수가 실행되는 동안 함수에서 사용할 수 있는 프로퍼티를 가진 유형의 객체라고 생각하면 이해하기 쉽다. 

``` js
function classroom(teacher) {
    return function study() {
        console.log(
            `${ teacher } 선생님이 ${ this.topic }을 공부하라고 했습니다.`
        );
    }
}

var assignment = classroom("카일");
```

예시에서 외부 함수 classroom()에는 지금까지 봤던 함수처럼 this 키워드를 참조하지 않는다. 그런데 내부 함수 study()에는 this가 있다. 이렇게 this가 있는 함수는 실행 컨텍스트에 종속되므로 함수를 제대로 이해하려면 this와 실행 컨텍스트의 작동 방식을 알아야 한다.

classroom("카일")을 호출하면 반환되는 내부 함수 study()는 변수 assignment에 할당된다. 이때 assignment()를 호출하면, 즉 study()를 호출하면 어떤 일이 벌어질까?

assignment()를 호출할 때 아무런 실행 컨텍스트를 제공하지 않고 일반 함수처럼 호출했기 때문에 예상치 않은 결과가 나타났다.

엄격 모드에서 예시를 실행하지 않았으므로 구체적인 컨텍스트를 지정하지 않고 실행하게 되면 기본 컨텍스트가 전역 객체가 된다. 전역에는 topic 이라는 변수가 없고 전역 객체에 topic이라는 프로퍼티 역시 없으므로 this.topic은 undefined가 되었다.

``` js
var homework = {
    topic: "JS",
    assignment: assignment
};

homework.assignment();
```

assignment 함수의 참조 복사본을 homework 객체의 프로퍼티로 설정하고 homework.assignment()를 호출했다. 이렇게 하면 함수를 호출할 때 this가 homework 객체가 된다. 따라서 this.topic은 "JS"가 된다.

``` js
var otherHomework = {
    topic: "수학"
};

assignment.call(otherHomework);
```
이번 예시에서는 함수를 호출할 때 this가 참조하는 객체를 결정하는 메서드인 call()을 용해 assignment 함수를 실행했다. 이렇게 하면 this.topic 프로퍼티는 "수학"을 참조한다.

assignment 함수는 this의 참조를 위해 실행 시 컨텍스트를 필수로 파악해야 한다. 

함수에서 this를 사용하면 컨텍스트를 동적으로 지정할 수 있고, 다른 객체에도 해당 함수를 재사용할 수 있어 매우 유연하다. 스코프가 지정된 함수는 다른 스코프를 참조할 수 없고 변수를 지정할 수도 없다. 하지만 this를 사용하면 동적으로 컨텍스트를 지정할 수 있으므로 특정한 작업 환경에서 아주 유용하다.