# this 다시 보기
this 키워드는 이미 다뤘지만, 함수를 호출할 때 프로토타입을 통해 발생하는 위임과 this를 함께 다루면 진가가 드러난다. 함수 호출 시 this가 동적으로 컨텍스트를 가져오는 중요한 이유는 프로토타입 체인을 통해 위임한 객체에 있는 메서드를 호출할 때, this가 코드 작성자의 의도대로 되게끔 하는 데 있다.

``` js
var homework = {
    study() {
        console.log(`${ this.topic }을 공부하세요`);
    }
};

var jsHomework = Object.create(homework);
jsHomework.topic = "JS";
jsHomework.study();
// JS을 공부하세요

var mathHomework = Object.create(homework);
mathHomework.topic = "수학";
mathHomework.study();
// 수학을 공부하세요
```
jsHomework와 mathHomework 객체는 프로토타입을 통해 만들어진 연결 장치로 study()라는 함수를 가진 homework 객체에 연결된다. jsHomework와 mathHomework 객체에는 topic이라는 프로퍼티가 있다.

jsHomework.study()는 homework.study()에 그 역할을 위임한다. 하지만 함수 호출 방식 덕분에 메서드 실행 시 메서드 내 this(this.topic)는 JS가 된다. 마찬가지로 mathHomework.study() 역시 그 역할을 homework.study()에 위임하는데, 메서드 내 this는 mathHomework이기 때문에 this.topic은 "수학"이 된다.

this가 homework였다면 이 코드는 그다지 유용하지 않았을 것이다.
그런데 상당수의 다른 언어에서는 study() 메서드가 실제로는 homework 객체에 정의되어 있으므로 this는 homework가 된다.

다른 언어들과 달리 JS에서는 this가 동적으로 결정된다. 이런 특징은 프로토타입을 통한 위임 특히 class에서 위임을 가능하게 만드는 중요한 요소이다.