## 3. 자바스크립트 뿌리 파헤치기

### 3.1 이터레이션

이터레이션 패터을 사용하면 데이터를 덩어리 단위로 표준화된 방법을 사용해 각각 처리할 수 있다.

데이터 전체를 한꺼번에 처리하기보다 데이터를 일정 단위로 쪼개고, 순회하며 점진적으로 처리하면 좀 더 범용적이고 유용할 거라는 아이디어에서 시작되었다.

JS에서도 이터레이셔 패턴을 명세서에 추가하려고 노력했고 ES6 명세서에 JS 내장 문법을 통해 이터레이터 패턴을 구현하는 구체적인 프로토콜이 추가되었다.

`next()` 메서드는 `이터레이터 리절트`라 불리는 객체를 반환하고, 이터레이터 리절트 객체에는 value와 done이라는 프로퍼티가 있어야한다고 규정한다. 반복 작업이 끝나지 않은 경우, done에는 boolean 값인 false가 저장되어야 한다.

### 3.1.1 이터레이터 소비하기

ES6에서는 for...of 반복문 같은 문법으로 이터레이터 리절트 객체를 소비할 수 있다.

```javascript
var it = /* ... */

for (let val of it) {
	console.log(`이터레이터 값: ${ val }`);
}
```

for...of 반복문 외에도 표현식 ...을 사용하면 이터레이터를 소비할 수 있다.

대칭 형태인 전개구문과 나머지 매개변수를 이용해 사용한다.

이 때 전개 구문이 바로 이터레이터를 소비하는 주체인 이터레이터 소비자다.

```javascript
var vals = [ ...it ];
doSomethingUseful( ...it );
```

### 3.1.2 이터러블

이터레이터 소비 프로토콜은 순회 가능한 값인 **이터러블**을 소비하는 기술적인 방법이다.

이터러블을 사용해 이터레이터 인스턴스를 생성하고, 생성한 이터레이터 인스턴스를 소비해 연산을 마무리한다.

JS에서 이터러블이란? ES6에서는 문자열, 배열, 맵, 셋 같이 기본이 되는 자료구조나 컬렉션을 이터러블로 정의한다

```javascript
var arr = [10, 20, 30];

for (let val of arr) {
	console.log(`${val}`);
}

// 얕은 복사
var arrCopy = [...arr];

var greeting = "Hello world!";
var chars = [ ...greeting ];

chars;
// ["H", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", "!"]
```

Map은 기본 이터레이터를 지원한다. Map의 내장 메서드 `entries`를 호출하면 맵의 값뿐 아니라 키까지 포함한 2차원 배열인 entry 튜플을 순회할 수 있다.

```javascript
var buttonNames = new Map();
buttonNames.set(btn1, "버튼 1");
buttonNames.set(btn2, "버튼 2");

for (let [btn, btnName] of buttonNames) {
	btn.addEventListener("click", function onClick() {
		console.log(`${ btnName }을/를 클릭했습니다`);
	})
}

// 정교한 이터레이션이 필요할 때. 예) 값만 추출하고 싶을 때
for (let btnName of buttonNames.values()) {
	console.log(btnName);
}

// 인덱스와 값을 대상으로 순회
var arr = [ 10, 20, 30 ];

for (let [idx, val] of arr.entries()) {
	console.log(`[${idx}]: ${val}`);
}
```

키만 대상: `keys()`

값만 대상: `values()`

키와 값을 대상: `entries()`

### 3.2 클로저

클로저는 JS에만 있는 기능은 아니다.

클로저는 함수가 정의된 스코프가 아닌 다른 스코프에서 함수가 실행되더라도, 스코프 밖에 있는 변수를 기억하고 이 외부 변수에 계속 접근할 수 있는 경우를 의미한다.

1. 객체는 클로저가 되지 않지만, 함수는 자연스럽게 클로저가 된다.
2. 클로저를 직접 보고 싶다면 함수를 해당 함수가 정의된 스코프가 아닌 다른 스코프에서 실행해야 한다.

```javascript
function greeting(msg) {
	return function who(name) {
		console.log(`${name} 님, ${msg}!`);
	}
}
var hello = greeting("안녕하세요");
var howdy = greeting("잘 지내시나요");
hello("카일"); // 카일 님, 안녕하세요!
hello("보라"); // 보라 님, 안녕하세요!
howdy("호진"); // 호진 님, 잘 지내시나요!
```

내부 함수 인스턴스들이 hello와 howdy에 각각 할당되면서 아직 살아있기 때문에 이들은 greeting()이 실행 종료된 후 가비지 컬렉션의 대상이 되지 않는다.

클로저는 변수 msg를 스냅숏한 값을 사용하지 않고 변수가 업데이트되는 것을 관찰하고 최신 값을 가져와서 사용한다

```javascript
function counter(step = 1) {
	var count = 0;
	return function increaseCount() {
		count = count + step;
		return count;
	};
}

var incBy1 = counter(1);
var incBy3 = counter(3);

incBy1(); // 1
incBy1(); // 2

incBy3(); // 3
incBy3(); // 6
```

### 3.3 this 키워드

함수는 this 키워드를 통해 실행 컨텍스트에 접근한다.

스코프는 **정적**이며 함수를 정의하는 순간, 해당 스코프에서 사용할 수 있는 한정된 변수 집합을 포함한다. 반면 함수의 실행 컨텍스트는 **동적**이다. 실행 컨텍스트는 함수를 정의한 위치나 함수를 호출하는 위치와 상관없이 **함수의 호출 방식**에 따라 결정된다.

this는 함수의 정의에 종속되어 결정되는 변치 않는 특징이 나닌, 함수를 호출할 때마다 결정되는 동적인 특성이다.

실행 컨텍스트는 함수가 실행되는 동안 함수에서 사용할 수 있는 프로퍼티를 가진 유형의 **객체**라고 생각하면 이해하기 쉽다. 스코프도 객체라고 생각할 수 있는데 스코프에서 객체는 JS 엔진 내부에 숨겨져 있고 함수 하나당 동일하며 프로퍼티의 경우 함수 내부에서 사용할 수 있는 식별자 형태를 띤다.

### 3.4 프로토타입

this가 함수 실행에 관한 특징이라면 프로토타입은 객체, 구체적으로 프로퍼티에 접근할 때 일어나는 동작과 관련된 특징이다.

프로포타입은 두 객체를 연결하는 연결 장치다.

프로토타입을 통해 연결된 일련의 객체는 프로토타입 체인이라고 부른다.

객체 B에서 다른 객체 A를 연결할 수 있게 하는 프로토타입 연결 장치가 존재하는 이유는 B에 없는 프로퍼티나 메서드에 접근하려 할 때, 객체 A에서 위임을 받아 해당 접근을 처리할 수 있도록 하기 위해서다.

```javascript
var homework = {
	topic: "JS"
};

// Object.prototype 위임으로 toString() 메서드 활용 가능
homework.toString(); // [object Object]
```

### 3.4.1 객체 연결 장치

객체 프로토타입 연결 장치를 직접 정의하고 싶을 때는 Object.create()를 사용해 객체를 만들면 된다.

```javascript
var homework = {
	topic: "JS"
};

var otherHomework = Object.create(homework);

otherHomework.topic; // "JS"
```

Object.create(null)을 호출하면 어떤 객체에도 연결되어 있지 않은 순수 독립 객체가 만들어진다.

ES6 이전에는 class 문법이 추가되기 전이어서 프로토타입 연결 장치를 사용해 객체를 만들려면 프로토타입 클래스라는 복잡한 패턴을 사용했다.

### 3.4.2 this 다시보기

함수를 호출할 때 프로토타입을 통해 발생하는 위임과 this를 함께 다루면 진가가 드러난다.

```javascript
var homework = {
	study() {
		console.log(`${this.topic}을/를 공부하세요.`);
	}
};

var jsHomework = Object.create(homework);
jsHomework.topic = "JS";
jsHomework.study();
// JS을/를 공부하세요.

var mathHomework = Object.create(homework);
mathHomework.topic = "수학";
mathHomework.study();
// 수학을/를 공부하세요.
```

### 3.5 '왜?'라고 질문하기

제대로 다루지 못하고 훑어보기만 한 세부 사항이 많기 때문에 올바른 질문을 하는 것이 더 나은 개발자로 만드는 중요한 기술이다.

1부의 마지막이 될 4장에서 YDKJSY 시리즈의 각 책에서 다루는 내용을 소개할 예정이고 부록 B에 1부에서 다룬 여러 가지 주제를 연습할 수 있는 문제가 있다.